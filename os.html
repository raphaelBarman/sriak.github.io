<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-05-26 Fri 18:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CS-323: Introduction to Operating Systems</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="theme.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CS-323: Introduction to Operating Systems</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc74c8e0">1. Lecture 1</a>
<ul>
<li><a href="#org84b1c2f">1.1. What does an OS do?</a></li>
<li><a href="#org3072f75">1.2. Where does the OS live?</a></li>
<li><a href="#org45d83b4">1.3. System calls</a></li>
<li><a href="#orgffc30ed">1.4. Traps</a></li>
<li><a href="#orgd578559">1.5. Interrupts</a></li>
<li><a href="#orgdf86604">1.6. OS control flow: event-driven program</a></li>
<li><a href="#org8807cd8">1.7. OS structure</a></li>
</ul>
</li>
<li><a href="#org18f4a6c">2. Lecture 2</a>
<ul>
<li><a href="#org616ccda">2.1. Process</a></li>
<li><a href="#orgfa49b66">2.2. Linux process tree</a></li>
<li><a href="#orged7810c">2.3. What does a process do?</a></li>
<li><a href="#orgadc2393">2.4. Process switch</a></li>
<li><a href="#org47faf43">2.5. Process scheduler</a></li>
</ul>
</li>
<li><a href="#org39f1360">3. Lecture 3</a>
<ul>
<li><a href="#orgc6ce57c">3.1. Multiprocess program</a></li>
<li><a href="#org0083062">3.2. Interprocess Communication (IPC)</a></li>
<li><a href="#org4b7db3d">3.3. Remote procedure call (RPC)</a></li>
</ul>
</li>
<li><a href="#org6b894c8">4. Lecture 4</a>
<ul>
<li><a href="#org3d794b1">4.1. Multi-threading vs. multi-processing</a></li>
<li><a href="#org157182e">4.2. Basic Approach to Multi-threading</a></li>
<li><a href="#orgabaa6a6">4.3. Locking</a></li>
<li><a href="#orgdaf5667">4.4. Pthreads: Condition variables</a></li>
<li><a href="#orgff3ef22">4.5. Kernel as a server</a></li>
</ul>
</li>
<li><a href="#org9c06fea">5. Lecture 5</a>
<ul>
<li><a href="#orga3484e8">5.1. Main Memory Allocation</a></li>
<li><a href="#orgfd0f139">5.2. Protection</a></li>
<li><a href="#orgf48693c">5.3. Transparency</a></li>
<li><a href="#org35a26a6">5.4. Virtual vs. Physical Address Space</a></li>
<li><a href="#org82807d6">5.5. Different Virtual/Physical Schemes</a></li>
<li><a href="#org5b6fae1">5.6. Typical Virtual Address Space</a></li>
<li><a href="#orged46956">5.7. Main Memory Allocation: processes</a></li>
<li><a href="#org23376d5">5.8. Swapping</a></li>
<li><a href="#orge98f8ed">5.9. Finer-Grain Protection</a></li>
<li><a href="#orga168c05">5.10. Sharing Memory between Processes</a></li>
<li><a href="#org66e3ca4">5.11. Translation Lookaside Buffer (TLB)</a></li>
</ul>
</li>
<li><a href="#orgebaea8d">6. Week 6</a>
<ul>
<li><a href="#orgc8015b4">6.1. Large Virtual Address Spaces</a></li>
<li><a href="#org4c2db3e">6.2. Process Switching and Memory Management</a></li>
</ul>
</li>
<li><a href="#org6fcbe97">7. Week 7</a>
<ul>
<li><a href="#org50d4805">7.1. Demand Paging</a></li>
<li><a href="#org17928ac">7.2. Page Replacement Policy</a></li>
<li><a href="#orge91444f">7.3. Frame Allocation</a></li>
<li><a href="#org2fa4c05">7.4. Optimization</a></li>
</ul>
</li>
<li><a href="#orgd8f7e89">8. Week 8</a>
<ul>
<li><a href="#org105c0b3">8.1. Files and type</a></li>
<li><a href="#org5c30f32">8.2. File System Primitives</a></li>
<li><a href="#org049120e">8.3. Disk terminology</a></li>
<li><a href="#orgd681f13">8.4. Disk Interface</a></li>
<li><a href="#org57fddf4">8.5. Disk Access</a></li>
</ul>
</li>
<li><a href="#org4bda38a">9. Week 9</a>
<ul>
<li><a href="#orgecf7811">9.1. Disk vs In. Memory</a></li>
<li><a href="#orgdd06cc4">9.2. Disk Data Structures</a></li>
<li><a href="#org054b42b">9.3. In-Memory Data Structures</a></li>
<li><a href="#org8f26c4f">9.4. Putting it All Together</a></li>
<li><a href="#org9b79f1b">9.5. Loose ends</a></li>
<li><a href="#org96f2406">9.6. Memory Mapping</a></li>
</ul>
</li>
<li><a href="#org1f43781">10. Week 10</a>
<ul>
<li><a href="#org5ed65ba">10.1. Atomicity</a></li>
<li><a href="#org40f6648">10.2. Log-Structured File System (LFS)</a></li>
</ul>
</li>
<li><a href="#org997b842">11. Week 11</a>
<ul>
<li><a href="#orgb6138f2">11.1. Disk issues</a></li>
<li><a href="#org2e9c9af">11.2. RAID</a></li>
<li><a href="#org0ef865b">11.3. RAID format</a></li>
<li><a href="#org1bf4482">11.4. SSD</a></li>
</ul>
</li>
<li><a href="#orgd9995ac">12. Week 12</a>
<ul>
<li><a href="#orgc83131e">12.1. Virtual machine</a></li>
<li><a href="#org6e59168">12.2. VMM implementation</a></li>
<li><a href="#orgc66ef56">12.3. Architecure-centric view of VMs: Popek/Goldberg Theorem</a></li>
<li><a href="#org2e984b9">12.4. Paravirtualization</a></li>
<li><a href="#org6ef714b">12.5. Conclusion</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Grading
</p>
<ul class="org-ul">
<li>Midterm 50%</li>
<li>Final 50%</li>
</ul>
<div id="outline-container-orgc74c8e0" class="outline-2">
<h2 id="orgc74c8e0"><span class="section-number-2">1</span> Lecture 1</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-org84b1c2f" class="outline-3">
<h3 id="org84b1c2f"><span class="section-number-3">1.1</span> What does an OS do?</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Abstracts the hardware (CPU, Memory, Disks, Devices), makes it easier to use (Process, Address space, File, Virtual Device)</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Hardware</th>
<th scope="col" class="org-left">Abstraction</th>
<th scope="col" class="org-left">OS Components</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">CPU</td>
<td class="org-left">Process</td>
<td class="org-left">Process Management</td>
</tr>

<tr>
<td class="org-left">Memory</td>
<td class="org-left">Address space</td>
<td class="org-left">Memory Management</td>
</tr>

<tr>
<td class="org-left">Disks</td>
<td class="org-left">File</td>
<td class="org-left">File Systems</td>
</tr>

<tr>
<td class="org-left">Devices</td>
<td class="org-left">Virtual Device</td>
<td class="org-left">Device Management</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Manages the resources of the hardware</li>
<li>OS does both abstraction and resource management
<ul class="org-ul">
<li>Web browser = only abstraction, not part of OS</li>
<li>Device driver = both, part of OS</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3072f75" class="outline-3">
<h3 id="org3072f75"><span class="section-number-3">1.2</span> Where does the OS live?</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>CPU operates in dual-mode, kernel mode vs user mode</li>
<li>Hardware mode bit</li>
<li>Kernel mode
<ul class="org-ul">
<li>Privileged instructions. Eg. set mode bit</li>
<li>Direct access to all of memory</li>
<li>Direct access to devices</li>
</ul></li>
<li>User mode
<ul class="org-ul">
<li>Applications</li>
<li>System programs (e.g daemons)</li>
</ul></li>
<li>Allow to separate user application to OS application</li>
<li>From user to kernel mode
<ul class="org-ul">
<li>Device generates interrupt</li>
<li>Program executes a system call</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org45d83b4" class="outline-3">
<h3 id="org45d83b4"><span class="section-number-3">1.3</span> System calls</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><b>only</b> way to access from program to OS</li>
<li>machine instruction</li>
<li>Kernel API: additional layer simplifying system calls</li>
<li>Language api, (eg. libc): wraps the kernel API
<ul class="org-ul">
<li>Makes system call look like function call</li>
<li>It is <b>not</b> a function call</li>
<li>It is a user-kernel transition</li>
<li>Much more expensive</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgffc30ed" class="outline-3">
<h3 id="orgffc30ed"><span class="section-number-3">1.4</span> Traps</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Generated by CPU as a result of error</li>
<li>Works like an "involuntary" system calls</li>
<li>Identified by a trap number</li>
</ul>
</div>
</div>
<div id="outline-container-orgd578559" class="outline-3">
<h3 id="orgd578559"><span class="section-number-3">1.5</span> Interrupts</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Generated by a device that needs attention</li>
<li>Identified by an interrupt number</li>
</ul>
</div>
</div>
<div id="outline-container-orgdf86604" class="outline-3">
<h3 id="orgdf86604"><span class="section-number-3">1.6</span> OS control flow: event-driven program</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>Nothing to do &rArr; do nothing, idle loop</li>
<li>interrupt (from device), trap, system call (from process) &rArr; start running</li>
</ul>
</div>
<div id="outline-container-orgd2ec932" class="outline-4">
<h4 id="orgd2ec932"><span class="section-number-4">1.6.1</span> What does the hardware on a {} i</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>Puts the machine in kernel mode</li>
<li>Sets the PC = {}Vector[i]</li>
<li>{}Vector is a predefined location</li>
</ul>
<p>
Where {} can be system call, trap, interrupt
</p>
</div>
</div>
<div id="outline-container-org8821cb8" class="outline-4">
<h4 id="org8821cb8"><span class="section-number-4">1.6.2</span> Simplified execution flow</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>User executes system call <i>i</i></li>
<li>Hardware 
<ul class="org-ul">
<li>Puts machine in kernel mode</li>
<li>Sets PC to SystemCallVector[i]</li>
</ul></li>
<li>Kernel  
<ul class="org-ul">
<li>Executes system call i handler routine (includes check on inbound parameters).</li>
<li>Executes a return from kernel instruction</li>
</ul></li>
<li>Hardware 
<ul class="org-ul">
<li>Puts machine in user mode</li>
</ul></li>
<li>User executes instruction aver system call</li>
</ul>
</div>
</div>
<div id="outline-container-orga9f4ead" class="outline-4">
<h4 id="orga9f4ead"><span class="section-number-4">1.6.3</span> OS design goals</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>Correct abstractions</li>
<li>Performance</li>
<li>Portability</li>
<li>Reliability</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8807cd8" class="outline-3">
<h3 id="org8807cd8"><span class="section-number-3">1.7</span> OS structure</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>OS is a huge piece of software</li>
<li>Something goes wrong in kernel mode</li>
<li>Incentive to move stuff out of kernel mode</li>
<li>No need for entire OS in kernel mode: some pieces can be in user mode, such as
daemons (e.g system logs)</li>
<li>Microkernel, absolute minimum in kernel mode, interprocess communication
primitives, all the rest in user mode</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org18f4a6c" class="outline-2">
<h2 id="org18f4a6c"><span class="section-number-2">2</span> Lecture 2</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-org616ccda" class="outline-3">
<h3 id="org616ccda"><span class="section-number-3">2.1</span> Process</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Process = program that currently executes</li>
<li>Process identification (pid) = unique identifier</li>
<li>Operations:
<ul class="org-ul">
<li>Create</li>
<li>Terminate
<ul class="org-ul">
<li>Normal exit</li>
<li>Error</li>
<li>Terminated by another process</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org9719e5b" class="outline-4">
<h4 id="org9719e5b"><span class="section-number-4">2.1.1</span> Linux process primitives</h4>
<div class="outline-text-4" id="text-2-1-1">
</div><div id="outline-container-org73fca18" class="outline-5">
<h5 id="org73fca18"><span class="section-number-5">2.1.1.1</span> pid = fork()</h5>
<div class="outline-text-5" id="text-2-1-1-1">
<ul class="org-ul">
<li>Creates an <i>identical</i> copy of parent</li>
<li>In parent, returns pid of child</li>
<li>In child returns 0</li>
</ul>
</div>
</div>
<div id="outline-container-org8d20d06" class="outline-5">
<h5 id="org8d20d06"><span class="section-number-5">2.1.1.2</span> exec( filename )</h5>
<div class="outline-text-5" id="text-2-1-1-2">
<p>
Loads executable from file with filename
</p>
</div>
</div>
<div id="outline-container-orgc60965a" class="outline-5">
<h5 id="orgc60965a"><span class="section-number-5">2.1.1.3</span> wait()</h5>
<div class="outline-text-5" id="text-2-1-1-3">
<p>
Wait for one of its children to terminate
</p>
</div>
</div>
<div id="outline-container-org7c52575" class="outline-5">
<h5 id="org7c52575"><span class="section-number-5">2.1.1.4</span> exit()</h5>
<div class="outline-text-5" id="text-2-1-1-4">
<p>
Terminate the process
</p>
</div>
</div>
<div id="outline-container-org5601af6" class="outline-5">
<h5 id="org5601af6"><span class="section-number-5">2.1.1.5</span> Example</h5>
<div class="outline-text-5" id="text-2-1-1-5">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #859900; font-weight: bold;">if</span><span style="color: #2aa198;">(</span> <span style="color: #268bd2;">pid</span> = fork<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #839496; font-weight: bold;">wait</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">else</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">exec</span><span style="color: #b58900;">(</span> filename <span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org721eb14" class="outline-4">
<h4 id="org721eb14"><span class="section-number-4">2.1.2</span> Linux shell</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">
<pre class="src src-shell">forever<span style="color: #2aa198;">{</span>
    <span style="color: #839496; font-weight: bold;">read</span> from input
    <span style="color: #859900; font-weight: bold;">if</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">logout</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">exit</span><span style="color: #b58900;">()</span>
    <span style="color: #859900; font-weight: bold;">if</span><span style="color: #b58900;">(</span> <span style="color: #268bd2;">pid</span> = fork<span style="color: #268bd2;">()</span> <span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #839496; font-weight: bold;">wait</span><span style="color: #268bd2;">()</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">exec</span><span style="color: #268bd2;">(</span> filename <span style="color: #268bd2;">)</span>
   <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0a72583" class="outline-4">
<h4 id="org0a72583"><span class="section-number-4">2.1.3</span> Operation</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
New command line (!= logout)
</p>
<ul class="org-ul">
<li>shell forks a new process and waits</li>
<li>Child executes program on cli</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfa49b66" class="outline-3">
<h3 id="orgfa49b66"><span class="section-number-3">2.2</span> Linux process tree</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-org5c39394" class="outline-4">
<h4 id="org5c39394"><span class="section-number-4">2.2.1</span> Boot</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>First process after boot is the init process</li>
<li>Happens by black magic</li>
</ul>
</div>
</div>
<div id="outline-container-org8c3efa9" class="outline-4">
<h4 id="org8c3efa9"><span class="section-number-4">2.2.2</span> User logs in</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>Init forks and waits</li>
<li>Child execs shell</li>
</ul>
</div>
</div>
<div id="outline-container-orgf8a68c6" class="outline-4">
<h4 id="orgf8a68c6"><span class="section-number-4">2.2.3</span> User runs make</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>Shell forks and waits</li>
<li>Child execs make</li>
</ul>
</div>
</div>
<div id="outline-container-orgf04188d" class="outline-4">
<h4 id="orgf04188d"><span class="section-number-4">2.2.4</span> Why fork+exec vs. create?</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
Process = environment (ownership,open files, values of env variables) + code
</p>

<p>
&rArr; child automatically inherits environment
</p>

<p>
This way, we can write code before exec, shell can manipulate environment of
child, e.g. can manipulate stdin and stdout.
</p>
</div>
</div>
</div>
<div id="outline-container-orged7810c" class="outline-3">
<h3 id="orged7810c"><span class="section-number-3">2.3</span> What does a process do?</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Either computes (use CPU)</li>
<li>Or does I/O</li>
</ul>
</div>
<div id="outline-container-orge2e2a3f" class="outline-4">
<h4 id="orge2e2a3f"><span class="section-number-4">2.3.1</span> Single process system</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>Very inefficient (very poor CPU utilization)</li>
<li>Very annoying (can't do anything else</li>
</ul>
</div>
</div>
<div id="outline-container-org9e5787f" class="outline-4">
<h4 id="org9e5787f"><span class="section-number-4">2.3.2</span> Multi-process system</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>Many process in the system</li>
<li>One uses CPU</li>
<li>When it does I/O, waits for I/O and leaves CPU idle</li>
<li>Another process get the CPU</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgadc2393" class="outline-3">
<h3 id="orgadc2393"><span class="section-number-3">2.4</span> Process switch</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Switch from one process running on the cpu to another process</li>
<li>Such that you can later switch back to the process currently holding the CPU</li>
</ul>
</div>
<div id="outline-container-org6a73c8f" class="outline-4">
<h4 id="org6a73c8f"><span class="section-number-4">2.4.1</span> Implementation</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Process consists of: 
</p>
<ul class="org-ul">
<li>Code (including libraries)</li>
<li>Stack</li>
<li>Heap</li>
<li>Registers (including PC)</li>
<li>MMU info (ignore for now)</li>
</ul>
</div>
</div>
<div id="outline-container-org122976e" class="outline-4">
<h4 id="org122976e"><span class="section-number-4">2.4.2</span> Process Control Block (PCB)</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
Register and MMU resides in shared locations, needs a way to save and restore
stuff when switching processes
</p>
<ul class="org-ul">
<li>Kernel must remember processes</li>
<li>Each process has a process control block (PCB)</li>
<li>Process control block contains</li>
<li>Process identifier (unique id)</li>
<li>Process state</li>
<li>Space to support process switch (save area)</li>
<li>Process Control Block Array</li>
<li>Indexed by hash( pid )</li>
</ul>
</div>
</div>
<div id="outline-container-orgdf98ad0" class="outline-4">
<h4 id="orgdf98ad0"><span class="section-number-4">2.4.3</span> Caveat</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>A process switch is an expensive operation!</li>
<li>Requires saving and restoring lots of stuff</li>
<li>Not just registers</li>
<li>Also MMU information</li>
<li>Has to be implemented very efficiently</li>
<li>Has to be used with care</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org47faf43" class="outline-3">
<h3 id="org47faf43"><span class="section-number-3">2.5</span> Process scheduler</h3>
<div class="outline-text-3" id="text-2-5">

<div class="figure">
<p><img src="Lecture 2/screenshot_2017-03-01_14-42-09.png" alt="screenshot_2017-03-01_14-42-09.png" />
</p>
</div>
</div>
<div id="outline-container-orgf52774b" class="outline-4">
<h4 id="orgf52774b"><span class="section-number-4">2.5.1</span> Preemptive vs Non-preemptive Scheduler</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Non-preemptive
</p>
<ul class="org-ul">
<li>Process only voluntarily relinquishes CPU</li>
</ul>
<p>
Preemptive
</p>
<ul class="org-ul">
<li>Process may be forced off CPU</li>
</ul>
</div>
<div id="outline-container-orge259906" class="outline-5">
<h5 id="orge259906"><span class="section-number-5">2.5.1.1</span> Advantages - Disadvantages</h5>
<div class="outline-text-5" id="text-2-5-1-1">
<ul class="org-ul">
<li>Non-preemptive
<ul class="org-ul">
<li>Process can monopolize CPU</li>
<li>Only useful in special circumstances</li>
</ul></li>
<li>Preemptive
<ul class="org-ul">
<li>Process can be thrown out at any time</li>
<li>Usually not a problem, but sometimes it is</li>
</ul></li>
<li>Intermediate solutions are possible</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org463cca1" class="outline-4">
<h4 id="org463cca1"><span class="section-number-4">2.5.2</span> Process Scheduling Implementation</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>Remember running process</li>
<li>Maintain sets of queues
<ul class="org-ul">
<li>(CPU) ready queue</li>
<li>I/O device queue (one per device)</li>
</ul></li>
<li>PCBs sit in queues</li>
</ul>
</div>
</div>
<div id="outline-container-orgcf04358" class="outline-4">
<h4 id="orgcf04358"><span class="section-number-4">2.5.3</span> How does the Scheduler run?</h4>
<div class="outline-text-4" id="text-2-5-3">
<ul class="org-ul">
<li>Scheduler is part of the kernel</li>
<li>Scheduler runs when
<ul class="org-ul">
<li>process starts or terminates (system call)</li>
<li>running process performs an I/O (system call)</li>
<li>I/O completes (I/O interrupt)</li>
<li>timer expires (timer interrupt)</li>
</ul></li>
<li>At end of handlers for
<ul class="org-ul">
<li>System calls</li>
<li>Interrupts</li>
<li>Traps</li>
</ul></li>
<li>Scheduler runs: decides on process to run</li>
<li>Switches to a new process</li>
<li>Sets another timer</li>
</ul>
</div>
</div>
<div id="outline-container-orgc2a16a3" class="outline-4">
<h4 id="orgc2a16a3"><span class="section-number-4">2.5.4</span> Scheduling Algorithm</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
Decides	which ready process gets to run	
</p>
</div>
<div id="outline-container-orge507434" class="outline-5">
<h5 id="orge507434"><span class="section-number-5">2.5.4.1</span> Interactive vs. Batch</h5>
<div class="outline-text-5" id="text-2-5-4-1">
<p>
Interactive = you are waiting for the result (short)
</p>
<ul class="org-ul">
<li>Needs short response time</li>
<li>response time = wait from ready to running</li>
<li>Scheduler run often</li>
</ul>
<p>
Batch = you will look at result later (long)
</p>
<ul class="org-ul">
<li>High throughput</li>
<li>Throughput = number of jobs completed</li>
<li>Scheduler is overhead</li>
</ul>
<p>
Often, scheduler does not know a priori if a process is interactive or batch   
</p>
</div>
</div>
</div>
<div id="outline-container-orgbdd49bd" class="outline-4">
<h4 id="orgbdd49bd"><span class="section-number-4">2.5.5</span> Example scheduling algorithms</h4>
<div class="outline-text-4" id="text-2-5-5">
</div><div id="outline-container-org1a762a5" class="outline-5">
<h5 id="org1a762a5"><span class="section-number-5">2.5.5.1</span> First come, first served (FCFS)</h5>
<div class="outline-text-5" id="text-2-5-5-1">
<ul class="org-ul">
<li>Process ready: insert at tail of queue</li>
<li>Head of queue: “oldest” ready process</li>
<li>By definition, non-preemptive</li>
</ul>


<ul class="org-ul">
<li>Low overhead – few scheduling events</li>
<li>Good throughput</li>
<li>Uneven response time – stuck behind long job</li>
<li>Extreme case – process monopolizes CPU</li>
</ul>
</div>
</div>
<div id="outline-container-org0672a6d" class="outline-5">
<h5 id="org0672a6d"><span class="section-number-5">2.5.5.2</span> Shortest Job First (SJF)</h5>
<div class="outline-text-5" id="text-2-5-5-2">
<ul class="org-ul">
<li>Process Ready, insert in queue according to length</li>
<li>Head of queue = "shortest" process</li>
<li>Can be preemptive or non-preemptive</li>
<li>From now on, only consider preemptive</li>
</ul>


<ul class="org-ul">
<li>Good response time for short jobs</li>
<li>Can lead to starvation of long jobs</li>
<li>Difficult to predict job length</li>
</ul>
</div>
</div>
<div id="outline-container-org6a7d801" class="outline-5">
<h5 id="org6a7d801"><span class="section-number-5">2.5.5.3</span> Round Robin (RR)</h5>
<div class="outline-text-5" id="text-2-5-5-3">
<ul class="org-ul">
<li>Define time quantum &Delta;</li>
<li>Process ready: put at tail of queue</li>
<li>Head of queue: run for &Delta; time</li>
<li>After &Delta;
<ul class="org-ul">
<li>Put running process at the tail of the queue</li>
<li>Re-schedule</li>
</ul></li>
</ul>


<ul class="org-ul">
<li>Short jobs finish quickly (a few rounds)</li>
<li>Long jobs not postponed forever</li>
<li>No need to know job length</li>
<li>Discover length by how many &Delta; 's it needs</li>
</ul>

<p>
How do we pick &Delta;?
</p>
<ul class="org-ul">
<li>If too small:
<ul class="org-ul">
<li>Many scheduling events</li>
<li>Good response time</li>
<li>Low throughput</li>
</ul></li>
<li>If too large:
<ul class="org-ul">
<li>Few scheduling events</li>
<li>Poor response time</li>
<li>Good throughput</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0ec3111" class="outline-5">
<h5 id="org0ec3111"><span class="section-number-5">2.5.5.4</span> Priority (PR)</h5>
<div class="outline-text-5" id="text-2-5-5-4">
<ul class="org-ul">
<li>Assign each process a priority Pr(P)</li>
<li>Process ready: insert in queue according to Pr(P)</li>
<li>Head of queue: highest-priority process</li>
</ul>


<ul class="org-ul">
<li>Differentiation according to job importance</li>
<li>Prone to starvation of low-priority jobs</li>
</ul>
</div>
</div>
<div id="outline-container-org5b6b497" class="outline-5">
<h5 id="org5b6b497"><span class="section-number-5">2.5.5.5</span> Priority + Aging (PR+A)</h5>
<div class="outline-text-5" id="text-2-5-5-5">
<ul class="org-ul">
<li>Assign each process a priority Pr(P)</li>
<li>Process ready: insert in q according to Pr(P)</li>
<li>Reduce priority over time</li>

<li>Lessens problem of starving low-priority jobs</li>
</ul>
</div>
</div>
<div id="outline-container-orgb9ac4a5" class="outline-5">
<h5 id="orgb9ac4a5"><span class="section-number-5">2.5.5.6</span> PR + RR</h5>
<div class="outline-text-5" id="text-2-5-5-6">
<ul class="org-ul">
<li>As with priority, but RR between process with equal priority</li>
<li>Typical implementation:
<ul class="org-ul">
<li>Multiple queues, one for each priority</li>
<li>Process ready: insert at tail of queue with its priority</li>
<li>Schedule: had of non-empty queue with highest priority for &Delta;</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0a56b67" class="outline-5">
<h5 id="org0a56b67"><span class="section-number-5">2.5.5.7</span> RR + FCFS</h5>
<div class="outline-text-5" id="text-2-5-5-7">
<ul class="org-ul">
<li>Two queues: one for RR, one for FCFS</li>
<li>Initially, process goes in RR queue</li>
<li>After n &Delta; 's, goes in FCFS queue</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org39f1360" class="outline-2">
<h2 id="org39f1360"><span class="section-number-2">3</span> Lecture 3</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgc6ce57c" class="outline-3">
<h3 id="orgc6ce57c"><span class="section-number-3">3.1</span> Multiprocess program</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Single process, too wasteful.</li>
<li>Multiprocess where you create a worker for each request = bad, because
creating a worker process is expensive</li>
<li>Better version = create a pool of worker and then dispatch work, then only
need to send a message to the worker</li>
</ul>
</div>
</div>
<div id="outline-container-org0083062" class="outline-3">
<h3 id="org0083062"><span class="section-number-3">3.2</span> Interprocess Communication (IPC)</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-org0ead7cc" class="outline-4">
<h4 id="org0ead7cc"><span class="section-number-4">3.2.1</span> Where is it needed?</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>Client-Server Communication</li>
<li>Between	cooperating process
<ul class="org-ul">
<li>Access to System Processes (e.g. user with daemon)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc716837" class="outline-4">
<h4 id="orgc716837"><span class="section-number-4">3.2.2</span> Message	passing primitives</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>Send / Receive</li>
<li>By value communication</li>
<li>Never by reference</li>
<li>Receiver cannot affect message in sender.</li>
</ul>
</div>
</div>
<div id="outline-container-org0e31787" class="outline-4">
<h4 id="org0e31787"><span class="section-number-4">3.2.3</span> Message Passing Implementation</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>Message sent to kernel, added to tail of pid proctable</li>
<li>Kernel sends it to the given pid</li>
</ul>
</div>
</div>
<div id="outline-container-org6eb42c0" class="outline-4">
<h4 id="org6eb42c0"><span class="section-number-4">3.2.4</span> Alternatives</h4>
<div class="outline-text-4" id="text-3-2-4">
</div><div id="outline-container-org79feef5" class="outline-5">
<h5 id="org79feef5"><span class="section-number-5">3.2.4.1</span> Symmetric addressing</h5>
<div class="outline-text-5" id="text-3-2-4-1">
<ul class="org-ul">
<li>Send(msg,topid)</li>
<li>Receive(msg,frompid)</li>
<li>Message is (typically) a struct</li>
<li>topid, frompid are process identifier</li>
<li>Symmetric addressing seldom used</li>
</ul>
</div>
</div>
<div id="outline-container-org53a39c0" class="outline-5">
<h5 id="org53a39c0"><span class="section-number-5">3.2.4.2</span> Assymetric addressing</h5>
<div class="outline-text-5" id="text-3-2-4-2">
<ul class="org-ul">
<li>Send( msg, pid ): Send msg to process pid</li>
<li>pid = Receive( msg )  
<ul class="org-ul">
<li>Receive msg from any process</li>
<li>Return the pid of sending process</li>
</ul></li>
<li>More common and useful form of addressing</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge41bb32" class="outline-4">
<h4 id="orge41bb32"><span class="section-number-4">3.2.5</span> Blocking or Nonblocking</h4>
<div class="outline-text-4" id="text-3-2-5">
</div><div id="outline-container-orgba7b083" class="outline-5">
<h5 id="orgba7b083"><span class="section-number-5">3.2.5.1</span> Send</h5>
<div class="outline-text-5" id="text-3-2-5-1">
<ul class="org-ul">
<li>Nonblocking: send returns immediately after message is sent</li>
<li>Blocking: sender blocks message is delivered</li>
<li>Nonblocking is the more common form</li>
</ul>
</div>
</div>
<div id="outline-container-orga563d92" class="outline-5">
<h5 id="orga563d92"><span class="section-number-5">3.2.5.2</span> Receive</h5>
<div class="outline-text-5" id="text-3-2-5-2">
<ul class="org-ul">
<li>Nonblocking  
<ul class="org-ul">
<li>Receive returns immediately</li>
<li>Regardless of message present or not</li>
</ul></li>
<li>Blocking: Receive blocks until message is present</li>
<li>Blocking is the more common form</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4b7db3d" class="outline-3">
<h3 id="org4b7db3d"><span class="section-number-3">3.3</span> <a href="https://fr.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call (RPC)</a></h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-org62f915d" class="outline-4">
<h4 id="org62f915d"><span class="section-number-4">3.3.1</span> RPC Interface</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>List of remotely callable procedures</li>
<li>With their arguments and return values</li>
</ul>
</div>
</div>
<div id="outline-container-orge3c99ea" class="outline-4">
<h4 id="orge3c99ea"><span class="section-number-4">3.3.2</span> Problem</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>Want a procedure call interface</li>
<li>Have only message passing between processes</li>
<li>How to bridge the gap?</li>
</ul>
</div>
</div>
<div id="outline-container-org30fbcdf" class="outline-4">
<h4 id="org30fbcdf"><span class="section-number-4">3.3.3</span> Stub library</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>Client stub and server stub</li>
<li>Client stub linked with client process</li>
<li>Server stub linked with server process</li>
</ul>
</div>
<div id="outline-container-orgdfa047b" class="outline-5">
<h5 id="orgdfa047b"><span class="section-number-5">3.3.3.1</span> Client Stub</h5>
<div class="outline-text-5" id="text-3-3-3-1">
<ul class="org-ul">
<li>Sends arguments in call message</li>
<li>Receiver return values in return message</li>
</ul>
</div>
</div>
<div id="outline-container-org0744605" class="outline-5">
<h5 id="org0744605"><span class="section-number-5">3.3.3.2</span> Server stub</h5>
<div class="outline-text-5" id="text-3-3-3-2">
<ul class="org-ul">
<li>Receives arguments in call message</li>
<li>Invokes procedure</li>
<li>Send returns in return message</li>
</ul>
</div>
</div>
<div id="outline-container-org8d9d673" class="outline-5">
<h5 id="org8d9d673"><span class="section-number-5">3.3.3.3</span> Example:</h5>
<div class="outline-text-5" id="text-3-3-3-3">
<p>
Client stub
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #268bd2;">GetTime</span><span style="color: #2aa198;">()</span>  
<span style="color: #2aa198;">{</span> 
    msg-&gt;procno = <span style="color: #6c71c4;">1</span> 
    Send<span style="color: #b58900;">(</span> msg <span style="color: #b58900;">)</span> 
    Receive<span style="color: #b58900;">(</span> msg <span style="color: #b58900;">)</span> 
    <span style="color: #859900; font-weight: bold;">return</span><span style="color: #b58900;">(</span> msg-&gt;retval0 <span style="color: #b58900;">)</span> 
<span style="color: #2aa198;">}</span> 
<span style="color: #268bd2;">SetTime</span><span style="color: #2aa198;">(</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">Bme</span> <span style="color: #2aa198;">)</span> 
<span style="color: #2aa198;">{</span> 
    msg-&gt;procno = <span style="color: #6c71c4;">2</span> 
    msg-&gt;arg0 = Bme 
    Send<span style="color: #b58900;">(</span> msg <span style="color: #b58900;">)</span> 
    Receive<span style="color: #b58900;">(</span> msg <span style="color: #b58900;">)</span> 
    <span style="color: #859900; font-weight: bold;">return</span><span style="color: #b58900;">(</span> msg-&gt;retval0 <span style="color: #b58900;">)</span> 
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Server stub
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #859900; font-weight: bold;">while</span><span style="color: #2aa198;">(</span> <span style="color: #268bd2; font-weight: bold;">true</span> <span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> 
  <span style="color: #2aa198;">{</span> 
    Receive<span style="color: #b58900;">(</span> msg <span style="color: #b58900;">)</span> 
    <span style="color: #859900; font-weight: bold;">switch</span> msg-&gt;procno <span style="color: #b58900;">{</span> 
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #6c71c4;">1</span>: <span style="color: #268bd2;">{</span> Bme = GetTime<span style="color: #6c71c4;">()</span> 
                        msg-&gt;retval0 = Bme 
                        Send<span style="color: #6c71c4;">(</span> msg <span style="color: #6c71c4;">)</span> <span style="color: #268bd2;">}</span> 
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #6c71c4;">2</span>: <span style="color: #268bd2;">{</span> ret = SetTime<span style="color: #6c71c4;">(</span> msg-&gt;arg0 <span style="color: #6c71c4;">)</span> 
                msg-&gt;retval0 = ret 
                Send<span style="color: #6c71c4;">(</span> msg <span style="color: #6c71c4;">)</span> <span style="color: #268bd2;">}</span> 
  <span style="color: #b58900;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org6b894c8" class="outline-2">
<h2 id="org6b894c8"><span class="section-number-2">4</span> Lecture 4</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-org3d794b1" class="outline-3">
<h3 id="org3d794b1"><span class="section-number-3">4.1</span> Multi-threading vs. multi-processing</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Processes provide separation  
<ul class="org-ul">
<li>In particular, memory separation (no shared data)</li>
<li>Suitable for coarse-grain interaction</li>
</ul></li>
<li>Threads do not  
<ul class="org-ul">
<li>In particular, share memory (shared data)</li>
<li>Suitable for tighter integration</li>
</ul></li>
</ul>
<p>
Most important difference:
</p>
<ul class="org-ul">
<li>Process crashes &rarr; other processes are not affected</li>
<li>Thread crashes &rarr; the entire process, including other threads, crashes</li>
</ul>
</div>
<div id="outline-container-orgf1df047" class="outline-4">
<h4 id="orgf1df047"><span class="section-number-4">4.1.1</span> Concrete Example: Web Server</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>Serving static content
<ul class="org-ul">
<li>Probably no bugs</li>
<li>Can easily be done in multi-threading process</li>
</ul></li>
<li>Serving dynamic (third-party) content
<ul class="org-ul">
<li>No guarantees about bugs</li>
<li>Keep in a different process</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org157182e" class="outline-3">
<h3 id="org157182e"><span class="section-number-3">4.2</span> Basic Approach to Multi-threading</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>Divide “work” among multiple threads</li>
<li>Which data is shared?  
<ul class="org-ul">
<li>Globals and heap</li>
<li>Not locals</li>
<li>Not readonly</li>
</ul></li>
<li>Where is shared data accessed?</li>
<li>Define one mutex</li>
<li>Put lock/unlock around each shared access</li>
<li>Put shared data access in critical section  
<ul class="org-ul">
<li>Only one process at a time can access it</li>
</ul></li>
</ul>
<p>
Mostly works, because:
</p>
<ul class="org-ul">
<li>Trouble with multi-threaded execution:
<ul class="org-ul">
<li>data races</li>
<li>data change by another thread</li>
</ul></li>
<li>Critical section: no other thread can change data</li>
</ul>
</div>
</div>
<div id="outline-container-orgabaa6a6" class="outline-3">
<h3 id="orgabaa6a6"><span class="section-number-3">4.3</span> Locking</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>Single lock strategies: Does not work very well, prevent good parallelism</li>
<li>Fine Grain Locking, define various separated locks</li>
<li>Privatization, define local variable, use lock only after heavy computation</li>
</ul>
</div>
</div>
<div id="outline-container-orgdaf5667" class="outline-3">
<h3 id="orgdaf5667"><span class="section-number-3">4.4</span> Pthreads: Condition variables</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>Pthread<sub>cond</sub><sub>wait</sub>(cond, mutex)
<ul class="org-ul">
<li>Wait for a signal on cond</li>
<li><b>Release mutex</b></li>
</ul></li>
<li><p>
Pthread<sub>cond</sub><sub>signalcond</sub>, mutex*)
</p>
<ul class="org-ul">
<li>Signal one thread waiting on cond</li>
<li>Signaled thread <b>re-acquire mutex</b> &rarr; at some later time, not necessarily immediately</li>
<li>if no thread waiting, no-op</li>
</ul>
<ul class="org-ul">
<li>Pthread<sub>cond</sub><sub>broadcast</sub>(cond, mutex)
<ul class="org-ul">
<li>Signal all threads waiting on cond</li>
<li>If not thread waiting, no-op</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org76d65db" class="outline-4">
<h4 id="org76d65db"><span class="section-number-4">4.4.1</span> Pthread Implementation</h4>
<div class="outline-text-4" id="text-4-4-1">
</div><div id="outline-container-orgb14d230" class="outline-5">
<h5 id="orgb14d230"><span class="section-number-5">4.4.1.1</span> Simplified</h5>
<div class="outline-text-5" id="text-4-4-1-1">
<ul class="org-ul">
<li>Pthreads primitives result in syscalls</li>
<li>Kernel runs when invoked</li>
</ul>
</div>
</div>
<div id="outline-container-orga5a4808" class="outline-5">
<h5 id="orga5a4808"><span class="section-number-5">4.4.1.2</span> Data Structures</h5>
<div class="outline-text-5" id="text-4-4-1-2">
<p>
Kernel maintains for each lock
</p>
<ul class="org-ul">
<li>Whether lock is held</li>
<li>If so, which thread holds lock</li>
<li>Queue of threads waiting to acquire lock</li>
</ul>
</div>
</div>
<div id="outline-container-orgbb49979" class="outline-5">
<h5 id="orgbb49979"><span class="section-number-5">4.4.1.3</span> Execution</h5>
<div class="outline-text-5" id="text-4-4-1-3">
<ul class="org-ul">
<li>On mutex<sub>lock</sub>
<ul class="org-ul">
<li>If lock is not held, set lock to held by this thread</li>
<li>If is held, queue this thread in queue for this lock</li>
</ul></li>
<li>On mutex<sub>unlock</sub>
<ul class="org-ul">
<li>In no threads in queue, set lock to not held</li>
<li>If thread in queue
<ul class="org-ul">
<li>Dequeue one thread from queue</li>
<li>Set lock to held by this thread</li>
<li>Add thread to ready queue</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgff3ef22" class="outline-3">
<h3 id="orgff3ef22"><span class="section-number-3">4.5</span> Kernel as a server</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>Requests from users: syscalls, traps</li>
<li>Requests from devices: interrupts</li>
<li>For simplicity, one kernel thread for each user thread, 1-to-1, case in Linus, not in other Oss</li>
</ul>
</div>
<div id="outline-container-orgb294300" class="outline-4">
<h4 id="orgb294300"><span class="section-number-4">4.5.1</span> How does it work?</h4>
<div class="outline-text-4" id="text-4-5-1">
</div><div id="outline-container-org92d344b" class="outline-5">
<h5 id="org92d344b"><span class="section-number-5">4.5.1.1</span> User to Kernel</h5>
<div class="outline-text-5" id="text-4-5-1-1">
<ul class="org-ul">
<li>User thread makes syscall</li>
<li>Switch to kernel mode</li>
<li>PC = system call handler routine</li>
<li>SP = kernel stack of kernel thread</li>
</ul>
</div>
</div>
<div id="outline-container-org51168ca" class="outline-5">
<h5 id="org51168ca"><span class="section-number-5">4.5.1.2</span> Kernel to User</h5>
<div class="outline-text-5" id="text-4-5-1-2">
<ul class="org-ul">
<li>SP = stack of user thread</li>
<li>PC = user thread PC (after syscall)</li>
<li>Return from kernel mode</li>
<li>Run in user thread</li>
</ul>
</div>
</div>
<div id="outline-container-orgb9433fb" class="outline-5">
<h5 id="orgb9433fb"><span class="section-number-5">4.5.1.3</span> Not: Separate Stack</h5>
<div class="outline-text-5" id="text-4-5-1-3">
<ul class="org-ul">
<li>User thread and corresponding kernel thread have separate stacks</li>
<li>Why? Security: While one thread of a process in kernel, other thread could modify stack</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org789f3f8" class="outline-4">
<h4 id="org789f3f8"><span class="section-number-4">4.5.2</span> Device interrupt</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
What makes kernel different.
</p>
<ul class="org-ul">
<li>Device interrupt</li>
<li>PC = interrupt handler</li>
<li>SP = interrupt thread stack</li>
<li>Run interrupt handler</li>
</ul>
</div>
</div>
<div id="outline-container-org72fbbcc" class="outline-4">
<h4 id="org72fbbcc"><span class="section-number-4">4.5.3</span> Kernel Synchronization</h4>
<div class="outline-text-4" id="text-4-5-3">
<ul class="org-ul">
<li>Different kernel threads access shared data</li>
<li>Must be synchronized</li>
<li>As in any multithreaded program</li>
<li>But interrupts make things different:
<ul class="org-ul">
<li>Must be server quickly</li>
<li>Interrupt handling must not block</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org471d1f8" class="outline-5">
<h5 id="org471d1f8"><span class="section-number-5">4.5.3.1</span> Solution</h5>
<div class="outline-text-5" id="text-4-5-3-1">
<ul class="org-ul">
<li>Add another set threads: Soft interrupt threads</li>
<li>Interrupt  
<ul class="org-ul">
<li>Does absolute minimum to service device</li>
<li>Never blocks!</li>
<li>Put request in queue for soft interrupt thread</li>
<li>Get soft interrupt thread ready</li>
</ul></li>
<li>Soft interrupt thread : Does bulk of work</li>
</ul>
</div>
</div>
<div id="outline-container-org5d4a5ab" class="outline-5">
<h5 id="org5d4a5ab"><span class="section-number-5">4.5.3.2</span> Advantages</h5>
<div class="outline-text-5" id="text-4-5-3-2">
<ul class="org-ul">
<li>Interrupts can be served quickly</li>
<li>Narrow interface: Interrupt and rest of the kernel</li>
<li>Soft interrupt threads ~ other kernel threads: With some exceptions, not going into it here</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org9c06fea" class="outline-2">
<h2 id="org9c06fea"><span class="section-number-2">5</span> Lecture 5</h2>
<div class="outline-text-2" id="text-5">
<p>
Assumption: Ignore L caches + for this week only: program in memory, only look
at processor and main memory, not disk.
</p>
</div>
<div id="outline-container-orga3484e8" class="outline-3">
<h3 id="orga3484e8"><span class="section-number-3">5.1</span> Main Memory Allocation</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-orgd7798b1" class="outline-4">
<h4 id="orgd7798b1"><span class="section-number-4">5.1.1</span> Allocating Main Memory for the kernel</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>Almost always in low memory</li>
<li>Why? Interrupt vectors are in low memory</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfd0f139" class="outline-3">
<h3 id="orgfd0f139"><span class="section-number-3">5.2</span> Protection</h3>
<div class="outline-text-3" id="text-5-2">
<p>
One process must not be able to read or write the memory of
</p>
<ul class="org-ul">
<li>another process</li>
<li>the kernel</li>
</ul>
<p>
Protected access: check before writing in memory, since must be done a lot,
implemented in hardware.
</p>
</div>
</div>
<div id="outline-container-orgf48693c" class="outline-3">
<h3 id="orgf48693c"><span class="section-number-3">5.3</span> Transparency</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Programmer should not have to worry   
</p>
<ul class="org-ul">
<li>where his program is in memory</li>
<li>where or what other programs are in memory</li>
</ul>
<p>
Program can be anywhere in main memory
</p>
</div>
</div>
<div id="outline-container-org35a26a6" class="outline-3">
<h3 id="org35a26a6"><span class="section-number-3">5.4</span> Virtual vs. Physical Address Space</h3>
<div class="outline-text-3" id="text-5-4">
<p>
What the program thinks is its memory vs where the program is in physical
memory.
</p>

<p>
Virtual addresses are mapped into physical address &rarr; done by the Memory
Management Unit (MMU, is hardware).
</p>
</div>
</div>
<div id="outline-container-org82807d6" class="outline-3">
<h3 id="org82807d6"><span class="section-number-3">5.5</span> Different Virtual/Physical Schemes</h3>
<div class="outline-text-3" id="text-5-5">
<p>
For each scheme:
</p>
<ul class="org-ul">
<li>Virtual address space</li>
<li>Physical address space</li>
<li>Virtual address</li>
<li>MMU</li>
</ul>
</div>
<div id="outline-container-orgc27cb48" class="outline-4">
<h4 id="orgc27cb48"><span class="section-number-4">5.5.1</span> Base and Bounds</h4>
<div class="outline-text-4" id="text-5-5-1">
</div><div id="outline-container-orgdbee063" class="outline-5">
<h5 id="orgdbee063"><span class="section-number-5">5.5.1.1</span> Virtual Address Space</h5>
<div class="outline-text-5" id="text-5-5-1-1">
<ul class="org-ul">
<li>Linear address space</li>
<li>From 0 to MAX</li>
</ul>
</div>
</div>
<div id="outline-container-orgcd81b28" class="outline-5">
<h5 id="orgcd81b28"><span class="section-number-5">5.5.1.2</span> Physical Address Space</h5>
<div class="outline-text-5" id="text-5-5-1-2">
<ul class="org-ul">
<li>Linear address space</li>
<li>From BASE to BOUNDS=BASE+MAX</li>
</ul>


<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_13-46-24.png" alt="screenshot_2017-03-22_13-46-24.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org5a8f517" class="outline-5">
<h5 id="org5a8f517"><span class="section-number-5">5.5.1.3</span> MMU for Base and Bounds</h5>
<div class="outline-text-5" id="text-5-5-1-3">
<ul class="org-ul">
<li>Relocation register: holds the base value</li>
<li>Limit register: holds the bounds value</li>
</ul>


<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_13-47-53.png" alt="screenshot_2017-03-22_13-47-53.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org6ca8fd9" class="outline-4">
<h4 id="org6ca8fd9"><span class="section-number-4">5.5.2</span> Segmentation</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>Virtual address space:  
<ul class="org-ul">
<li>Two-dimensional</li>
<li>Set of segments 0..n</li>
<li>Each segment i is linear from 0 to MAX<sub>i</sub></li>
</ul></li>
<li>Physical address space  
<ul class="org-ul">
<li>Set of segments, each linear</li>
</ul></li>
</ul>

<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_13-50-17.png" alt="screenshot_2017-03-22_13-50-17.png" />
</p>
</div>

<p>
What is a Segment:
</p>
<ul class="org-ul">
<li>Anything you want it to be, eg. code, heap stack</li>
</ul>
</div>
<div id="outline-container-orgc3f62fa" class="outline-5">
<h5 id="orgc3f62fa"><span class="section-number-5">5.5.2.1</span> Virtual Address</h5>
<div class="outline-text-5" id="text-5-5-2-1">
<ul class="org-ul">
<li>Two-dimensional address:  
<ul class="org-ul">
<li>Segment number s</li>
<li>Offset d within segment (starting at 0)</li>
</ul></li>
<li>It is like multiple base-and-bounds</li>
</ul>
</div>
</div>
<div id="outline-container-orgac7a607" class="outline-5">
<h5 id="orgac7a607"><span class="section-number-5">5.5.2.2</span> MMU</h5>
<div class="outline-text-5" id="text-5-5-2-2">
<ul class="org-ul">
<li>STBR: points to segment table in memory</li>
<li>STLR: length of segment table</li>
<li>Segment table  
<ul class="org-ul">
<li>Indexed by segment number</li>
<li>Contains (base, limit) pair</li>
<li>Base: physical address of segment in memory</li>
<li>Limit: length of segment</li>
</ul></li>
</ul>
<p>
<img src="files/Lecture 5/screenshot_2017-03-22_13-53-51.png" alt="screenshot_2017-03-22_13-53-51.png" />
A segment for each process
</p>
</div>
</div>
</div>
<div id="outline-container-orgce8e52c" class="outline-4">
<h4 id="orgce8e52c"><span class="section-number-4">5.5.3</span> (Simplified) Paging</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li>Page: fixed-size portion of virtual memory</li>
<li>Frame: fixed-size portion of physical memory</li>
<li><b>Page size = frame size</b></li>
<li>Typical size: 4k – 8k (always power of 2)</li>
</ul>
<p>
Virtual Address Space: linear from 0 up to a multiple of page size
Physical Address Space: Non-contiguous set of frames, one per page
</p>


<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_13-59-29.png" alt="screenshot_2017-03-22_13-59-29.png" />
</p>
</div>
</div>
<div id="outline-container-orga5590c1" class="outline-5">
<h5 id="orga5590c1"><span class="section-number-5">5.5.3.1</span> Virtual Address</h5>
<div class="outline-text-5" id="text-5-5-3-1">
<ul class="org-ul">
<li>Virtual address: 0 - MAX (page size multiple)</li>
<li>Page size = 2<sup>n</sup></li>
<li>Virtual address for mapping purposes:
<ul class="org-ul">
<li>Page number p: first sequence of bits</li>
<li>Offset within page d: n remaining bits</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3596ca4" class="outline-5">
<h5 id="org3596ca4"><span class="section-number-5">5.5.3.2</span> MMU</h5>
<div class="outline-text-5" id="text-5-5-3-2">
<ul class="org-ul">
<li>PTBR: points to page table in memory</li>
<li>PTLR: length of page table</li>
<li>Page table  
<ul class="org-ul">
<li>Indexed by page number</li>
<li>Contains frame number of page in memory</li>
</ul></li>
</ul>

<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_14-02-10.png" alt="screenshot_2017-03-22_14-02-10.png" />
</p>
</div>

<p>
p not visible to the program, not as in segmentation, where the programs sees s.
</p>
</div>
</div>
</div>
<div id="outline-container-org0597ef9" class="outline-4">
<h4 id="org0597ef9"><span class="section-number-4">5.5.4</span> Segmentation with Paging</h4>
<div class="outline-text-4" id="text-5-5-4">
<p>
As segmentation, but every segment is paged.
</p>
<ul class="org-ul">
<li>Virtual address space:
<ul class="org-ul">
<li>two-dimensional</li>
<li>Set of segments 0..n</li>
<li>Each segment linear from 0 to MAX<sub>i</sub></li>
<li>MAX<sub>i</sub> now a multiple of page size</li>
</ul></li>
<li>Physical address space: non-contiguous set of frames</li>
</ul>
</div>
<div id="outline-container-orga9c9c2c" class="outline-5">
<h5 id="orga9c9c2c"><span class="section-number-5">5.5.4.1</span> Virtual Address</h5>
<div class="outline-text-5" id="text-5-5-4-1">
<ul class="org-ul">
<li>Virtual Address:
<ul class="org-ul">
<li>Segment number s</li>
<li>Offset with segment d</li>
</ul></li>
<li>Virtual address for mapping
<ul class="org-ul">
<li>Segment number s</li>
<li>Page number within segment p</li>
<li>Offset within page d'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5524204" class="outline-5">
<h5 id="org5524204"><span class="section-number-5">5.5.4.2</span> MMU</h5>
<div class="outline-text-5" id="text-5-5-4-2">
<ul class="org-ul">
<li>STBR: points to segment table in memory</li>
<li>STLR: length of segment table</li>
<li>Segment table:  
<ul class="org-ul">
<li>Indexed by segment number</li>
<li>Contains page table base, segment length</li>
</ul></li>
<li>Page table for each segment:  
<ul class="org-ul">
<li>Index by page number</li>
<li>Contains frameno of frame that contains page</li>
</ul></li>
</ul>

<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-03-22_14-26-05.png" alt="screenshot_2017-03-22_14-26-05.png" />
</p>
</div>

<p>
Here we need
</p>
<ul class="org-ul">
<li>1 segment table per process</li>
<li>We need 1 page table per valid segment of a process</li>
<li>Tables are located</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org5b6fae1" class="outline-3">
<h3 id="org5b6fae1"><span class="section-number-3">5.6</span> Typical Virtual Address Space</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Linear from 0 up to a multiple of page size, true, but address space is often
sparsely used.
</p>

<p>
Problem: Access to unused portion will appear valid, would prefer to have an
error
</p>
</div>
<div id="outline-container-org199c006" class="outline-4">
<h4 id="org199c006"><span class="section-number-4">5.6.1</span> Solution</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>Abandon PTLR</li>
<li>Page table has length 2<sup>p</sup></li>
<li>Instead, have valid bit in each PTE  
<ul class="org-ul">
<li>Set to valid for used portions of address space</li>
<li>Invalid for unused portions</li>
</ul></li>
<li>This is the common approach</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orged46956" class="outline-3">
<h3 id="orged46956"><span class="section-number-3">5.7</span> Main Memory Allocation: processes</h3>
<div class="outline-text-3" id="text-5-7">
<p>
We want as many processes in memory, in order to be able to quickly switch on
I/O of running process.
</p>

<p>
Question: how to find memory for a newly arrived process?
</p>
</div>
<div id="outline-container-orgbd2f40b" class="outline-4">
<h4 id="orgbd2f40b"><span class="section-number-4">5.7.1</span> Base and Bounds</h4>
<div class="outline-text-4" id="text-5-7-1">
<ul class="org-ul">
<li>Main memory:
<ul class="org-ul">
<li>Regions in use</li>
<li>"Holes"</li>
</ul></li>
<li>New process needs to go in "hole"</li>
<li>Which hole to pick?</li>
</ul>
</div>
<div id="outline-container-org4d3e659" class="outline-5">
<h5 id="org4d3e659"><span class="section-number-5">5.7.1.1</span> Dynamic Memory Allocation Methods</h5>
<div class="outline-text-5" id="text-5-7-1-1">
<ul class="org-ul">
<li>First-fit  
<ul class="org-ul">
<li>Take first hole bigger than requested</li>
<li>Easy to find</li>
</ul></li>
<li>Best-fit  
<ul class="org-ul">
<li>Take smallest hole bigger than requested</li>
<li>Leaves smallest hole behind</li>
</ul></li>
<li>Worst-fit?!  
<ul class="org-ul">
<li>Takes largest hole</li>
<li>Leaves biggest hole behind</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1356806" class="outline-5">
<h5 id="org1356806"><span class="section-number-5">5.7.1.2</span> (External) Fragmentation</h5>
<div class="outline-text-5" id="text-5-7-1-2">
<ul class="org-ul">
<li>Small holes become unusable</li>
<li>Part of memory cannot be used</li>
<li>Serious problem</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org15f4fd1" class="outline-4">
<h4 id="org15f4fd1"><span class="section-number-4">5.7.2</span> Segmentation</h4>
<div class="outline-text-4" id="text-5-7-2">
<ul class="org-ul">
<li>Problem is similar  
<ul class="org-ul">
<li>Dynamic memory allocation</li>
<li>Pieces are typically smaller</li>
<li>But there are more (than 1) pieces</li>
</ul></li>
<li>Easier problem  
<ul class="org-ul">
<li>External fragmentation smaller</li>
</ul></li>
</ul>
<p>
No place wasted inside a segment.
</p>
</div>
</div>
<div id="outline-container-org408983a" class="outline-4">
<h4 id="org408983a"><span class="section-number-4">5.7.3</span> Paging</h4>
<div class="outline-text-4" id="text-5-7-3">
<ul class="org-ul">
<li>Logical address space: fixed size pages  
<ul class="org-ul">
<li>Physical address space: fixed size frames</li>
</ul></li>
<li>New process:  
<ul class="org-ul">
<li>Find frames for all of process’s pages</li>
</ul></li>
<li>Easier problem  
<ul class="org-ul">
<li>Fixed size</li>
</ul></li>
</ul>
<p>
No need to keep a list of holes with size, only need to keep location of holes,
already at the right size.
</p>

<p>
No external fragmentation, but internal fragmentation, since fixed size, par of
last page may be unused, not a big problem with reasonable page size.
</p>
</div>
</div>
</div>
<div id="outline-container-org23376d5" class="outline-3">
<h3 id="org23376d5"><span class="section-number-3">5.8</span> Swapping</h3>
<div class="outline-text-3" id="text-5-8">
<p>
What if we are out of memory?
</p>
<ul class="org-ul">
<li>We need to get rid of one or more process</li>
<li>Store them temporarily on disk</li>
<li>Called swapping</li>
<li>/!\ Whole process, not part of it</li>
</ul>
<p>
Process switch to a swapped process?
</p>
<ul class="org-ul">
<li>Latency can be very high</li>
<li>Need to read image from disk&#x2026;</li>
<li>Better solution = demand paging, not all of a process needs to be in memory</li>
</ul>
</div>
</div>
<div id="outline-container-orge98f8ed" class="outline-3">
<h3 id="orge98f8ed"><span class="section-number-3">5.9</span> Finer-Grain Protection</h3>
<div class="outline-text-3" id="text-5-9">
<p>
Different protection for different parts of address space
</p>
<ul class="org-ul">
<li>Valid bit in page table</li>
<li>May also have valid bit in segment table</li>
<li>May also have other bits in page/segment table
<ul class="org-ul">
<li>Read-only / Read-write</li>
<li>Executable / not-executable</li>
</ul></li>
</ul>

<p>
For instance, code should be valid, read-only and executable:
</p>
<ul class="org-ul">
<li>Base and bounds: not really possible</li>
<li>Segmentation: Set those bits in segment table</li>
<li>Paging: Set those bit in every code page</li>

<li>Easier to do with segmentation</li>
<li>Segments correspond to logical entities</li>
<li>Typically have the same protection attributes</li>
</ul>
</div>
</div>
<div id="outline-container-orga168c05" class="outline-3">
<h3 id="orga168c05"><span class="section-number-3">5.10</span> Sharing Memory between Processes</h3>
<div class="outline-text-3" id="text-5-10">
</div><div id="outline-container-org37621f1" class="outline-4">
<h4 id="org37621f1"><span class="section-number-4">5.10.1</span> Why?</h4>
<div class="outline-text-4" id="text-5-10-1">
<ul class="org-ul">
<li>Run twice the same program in different processes, may want to share code</li>
<li>Read twice the same file in different processes, may want to share memory
corresponding to file</li>
</ul>
</div>
</div>
<div id="outline-container-orge2f3155" class="outline-4">
<h4 id="orge2f3155"><span class="section-number-4">5.10.2</span> How?</h4>
<div class="outline-text-4" id="text-5-10-2">
<p>
Processes occasionally share memory
</p>
<ul class="org-ul">
<li>With base and bounds, not possible</li>
<li>With segmentation
<ul class="org-ul">
<li>Create segment for shared data</li>
<li>Entry in segment table of both processes</li>
<li>Points to shared segment in memory</li>
</ul></li>
<li>With paging
<ul class="org-ul">
<li>Need to share pages</li>
<li>Entries in page table of both processes</li>
<li>Point to shared pages</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0456ab7" class="outline-4">
<h4 id="org0456ab7"><span class="section-number-4">5.10.3</span> Advantages/Disadvantages</h4>
<div class="outline-text-4" id="text-5-10-3">
<p>
Easier to do with segmentation
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Segmentation</th>
<th scope="col" class="org-left">Paging</th>
<th scope="col" class="org-left">Segmentation with Paging</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Sharing</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">Fine-grain protection</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-left">Memory allocation</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org4fea496" class="outline-4">
<h4 id="org4fea496"><span class="section-number-4">5.10.4</span> In Reality</h4>
<div class="outline-text-4" id="text-5-10-4">
<ul class="org-ul">
<li>Based-and-bounds only for niche</li>
<li>Segmentation abandoned
<ul class="org-ul">
<li>Complexity for little gain</li>
<li>Effect approximated with paging with valid bits</li>
</ul></li>
<li>Paging is now universal</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org66e3ca4" class="outline-3">
<h3 id="org66e3ca4"><span class="section-number-3">5.11</span> Translation Lookaside Buffer (TLB)</h3>
<div class="outline-text-3" id="text-5-11">
<p>
Solves performance issue, since page table in memory, 1 virtual address &rarr; 2
physical memory accesses, reduces performance by 2.
</p>

<p>
TLB:
</p>
<ul class="org-ul">
<li>Small fast cache of (pageno,frameno) maps</li>
<li>If mapping for pageno found in TLB
<ul class="org-ul">
<li>Use frameno from TLB</li>
<li>Abort mapping using page table</li>
</ul></li>
<li>If not
<ul class="org-ul">
<li>Perform mapping using page table</li>
<li>Insert (pageno,frameno) in TLB</li>
</ul></li>
</ul>


<div class="figure">
<p><img src="files/Lecture 5/screenshot_2017-04-18_14-31-00.png" alt="screenshot_2017-04-18_14-31-00.png" />
</p>
</div>
</div>

<div id="outline-container-orgaeffe02" class="outline-4">
<h4 id="orgaeffe02"><span class="section-number-4">5.11.1</span> How to make TLB fast?</h4>
<div class="outline-text-4" id="text-5-11-1">
<ul class="org-ul">
<li>Use associative memory (special HW)</li>
<li>Regular memory: lookup by address</li>
<li>Associative memory: lookup by contents</li>
</ul>
</div>
</div>
<div id="outline-container-org54b89c5" class="outline-4">
<h4 id="org54b89c5"><span class="section-number-4">5.11.2</span> TLB Size</h4>
<div class="outline-text-4" id="text-5-11-2">
<ul class="org-ul">
<li>Associative memory very expensive</li>
<li>Therefore, TLB small (64-1024 entries)</li>
<li>If TLB full, need to replace existing entry</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgebaea8d" class="outline-2">
<h2 id="orgebaea8d"><span class="section-number-2">6</span> Week 6</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgc8015b4" class="outline-3">
<h3 id="orgc8015b4"><span class="section-number-3">6.1</span> Large Virtual Address Spaces</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>64-bit virtual address space</li>
<li>4kB pages (12-bit page offset)</li>
<li>Leaves 52 bits for pageno</li>
<li>Would require 2<sup>52</sup> page table entries</li>
<li>Let’s say every page table entry 4 bytes</li>
<li>Page table size = 2<sup>54</sup> bytes</li>
<li>More than main memory!</li>
</ul>
</div>
<div id="outline-container-orgf310159" class="outline-4">
<h4 id="orgf310159"><span class="section-number-4">6.1.1</span> Single vs two level page tables</h4>
<div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>Single: Virtual address is broken in two parts, one for page, other for offset</li>
<li>Two level, first part is broken in two parts</li>
</ul>
</div>
</div>
<div id="outline-container-org1a333e0" class="outline-4">
<h4 id="org1a333e0"><span class="section-number-4">6.1.2</span> MMU for Two-level Page Tables</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li>PTBR: points to top-level page table</li>
<li>Top-level page table entry:</li>
<li>Indexed by p1</li>
<li>Pointer to second-level page table</li>
<li>Valid bit</li>
<li>Second-level page table entry:</li>
<li>Indexed by p2</li>
<li>Frameno containing page (p1,p2)</li>
<li>Valid bit</li>
</ul>


<div class="figure">
<p><img src="files/Week 6/screenshot_2017-04-18_14-39-31.png" alt="screenshot_2017-04-18_14-39-31.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org844e030" class="outline-4">
<h4 id="org844e030"><span class="section-number-4">6.1.3</span> Memory Use</h4>
<div class="outline-text-4" id="text-6-1-3">
<ul class="org-ul">
<li>most address spaces are sparsely populated</li>
</ul>
<p>
-One-level: need page table for entire address space
</p>
<ul class="org-ul">
<li>Two-level:
<ul class="org-ul">
<li>need top-level page table for entire address space</li>
<li>Need only second-level page tables for populated parts of the address space</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7b8385d" class="outline-4">
<h4 id="org7b8385d"><span class="section-number-4">6.1.4</span> Example</h4>
<div class="outline-text-4" id="text-6-1-4">
<ul class="org-ul">
<li>Virtual address – 32 bits</li>
<li>Only low 20Mb and upper 2Mb valid</li>
<li>Page size – 4k or d = 12 bits, so p = 20 bits</li>
<li>1-level page table: 2<sup>20</sup> = 1M PTEs</li>
<li>2-level page table (P1 = 8, P2 = 12) 
<ul class="org-ul">
<li>2<sup>8</sup> for 1 st  level</li>
<li>2 x 2<sup>12</sup> + 1 x 2<sup>12</sup> for 2 nd  level</li>
<li>~12K PTEs</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfd8411e" class="outline-4">
<h4 id="orgfd8411e"><span class="section-number-4">6.1.5</span> Dense Address spaces</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
Two level: not useful, even counter-productive, but most address spaces are
sparse
</p>
</div>
</div>
<div id="outline-container-orga3be0de" class="outline-4">
<h4 id="orga3be0de"><span class="section-number-4">6.1.6</span> Two-level enough?</h4>
<div class="outline-text-4" id="text-6-1-6">
<ul class="org-ul">
<li>Second-level page table fits in a page</li>
<li>Easy to allocate</li>
<li>Let’s assume 
<ul class="org-ul">
<li>4k pages</li>
<li>4 bytes per PTE</li>
</ul></li>
<li>It follows: d = 12, p2 = 10</li>
<li>Two level:
<ul class="org-ul">
<li>p1 = 42</li>
<li>top level = 2<sup>42</sup> entries</li>
</ul></li>
<li>3-level: p1 = 32, p2 = 10, p3 = 10</li>
<li>4-level: p1 = 22, p2 = 10, p3 = 10, p4 = 10</li>
</ul>
</div>
</div>
<div id="outline-container-orgc573ff6" class="outline-4">
<h4 id="orgc573ff6"><span class="section-number-4">6.1.7</span> Cost of more levels</h4>
<div class="outline-text-4" id="text-6-1-7">
<ul class="org-ul">
<li>Each level adds another memory access</li>
<li>N-level page table: 1 memory access &rarr; n+1 memory accesses</li>
<li>But, TLB still works 
<ul class="org-ul">
<li>If hit, 1 memory access &rarr; 1 memory accesses</li>
<li>If miss, 1 memory access  &rarr;  n+1 memory accesses</li>
</ul></li>
<li>TLB hit rate must be very high (99+ %)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4c2db3e" class="outline-3">
<h3 id="org4c2db3e"><span class="section-number-3">6.2</span> Process Switching and Memory Management</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-org1eb6ef2" class="outline-4">
<h4 id="org1eb6ef2"><span class="section-number-4">6.2.1</span> Memory  Mapping Info</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
When process switching, need to save and restore PC and registers, but also
needs to restore memory mapping information.
</p>

<ul class="org-ul">
<li>Base and bounds: base and limit integer</li>
<li>Segmentation: STBR and STLR</li>
<li>Paging: PTBR and PTLR</li>
</ul>
<p>
(Need not save/restore segment and page table, already in memory)
</p>
</div>
</div>
<div id="outline-container-org8e44202" class="outline-4">
<h4 id="org8e44202"><span class="section-number-4">6.2.2</span> Process switching and TLB</h4>
<div class="outline-text-4" id="text-6-2-2">
</div><div id="outline-container-org7518a39" class="outline-5">
<h5 id="org7518a39"><span class="section-number-5">6.2.2.1</span> Issue</h5>
<div class="outline-text-5" id="text-6-2-2-1">
<ul class="org-ul">
<li>Suppose 
<ul class="org-ul">
<li>Process P1 is running</li>
<li>Entry (pageno, frameno) in TLB</li>
<li>Switch from P1 to P2</li>
<li>P2 issues virtual address in page pageno</li>
</ul></li>
<li>P2 accesses P1’s memory!</li>
</ul>
</div>
</div>
<div id="outline-container-org4f1eb82" class="outline-5">
<h5 id="org4f1eb82"><span class="section-number-5">6.2.2.2</span> Solution 1</h5>
<div class="outline-text-5" id="text-6-2-2-2">
<p>
On process switch, invalidate all TLB entries 
</p>
<ul class="org-ul">
<li>Simply requires invalid bit in each TLB entry</li>
<li>Makes process switch expensive</li>
<li>New process initially incurs 100% TLB misses</li>
</ul>
</div>
</div>
<div id="outline-container-org3b6105f" class="outline-5">
<h5 id="org3b6105f"><span class="section-number-5">6.2.2.3</span> Solution 2</h5>
<div class="outline-text-5" id="text-6-2-2-3">
<ul class="org-ul">
<li>Have process identifier in TLB entries 
<ul class="org-ul">
<li>Match = match on pid and match on pageno</li>
<li>Makes TLB more complicated and expensive</li>
</ul></li>
<li>Process switch  
<ul class="org-ul">
<li>Nothing to do</li>
<li>Cheaper</li>
</ul></li>
<li>All modern machines have this feature</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org6fcbe97" class="outline-2">
<h2 id="org6fcbe97"><span class="section-number-2">7</span> Week 7</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-org50d4805" class="outline-3">
<h3 id="org50d4805"><span class="section-number-3">7.1</span> Demand Paging</h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-org4acd5c8" class="outline-4">
<h4 id="org4acd5c8"><span class="section-number-4">7.1.1</span> Introduction</h4>
<div class="outline-text-4" id="text-7-1-1">
<ul class="org-ul">
<li>Virtual address space &gt; physical address space, large because we don't want to
worry about running out</li>
</ul>
<p>
Other benefits:
</p>
<ul class="org-ul">
<li>Shorter process startup latency 
<ul class="org-ul">
<li>Can start process without all of it in memory</li>
<li>Even 1 page suffices</li>
</ul></li>
<li>Better use of main memory
<ul class="org-ul">
<li>Program often do not use certain parts, E.g., error
handling routines</li>
</ul></li>
<li>Program often goes through different parts, E.g., initialization, computation,
termination</li>
</ul>
<p>
If the program is not in memory, where?
</p>
<ul class="org-ul">
<li>Part in memory</li>
<li>(Typically) all of it on disk</li>
<li>Different from swapping, where all program on disk or all on memory</li>
</ul>
<p>
Also
</p>
<ul class="org-ul">
<li>CPU can only directly access memory</li>
<li>CPU can only access data on disk through OS</li>
</ul>
</div>
</div>
<div id="outline-container-org610f621" class="outline-4">
<h4 id="org610f621"><span class="section-number-4">7.1.2</span> Process</h4>
<div class="outline-text-4" id="text-7-1-2">
<ul class="org-ul">
<li>If program accesses part only on disk &rarr; <b>page fault</b></li>
<li>Program is suspended</li>
<li>OS runs, get page from disk</li>
<li>Program is restarted &rarr; <b>page fault handling</b></li>
</ul>
</div>
</div>
<div id="outline-container-orgbfd27dc" class="outline-4">
<h4 id="orgbfd27dc"><span class="section-number-4">7.1.3</span> Discover page fault</h4>
<div class="outline-text-4" id="text-7-1-3">
<ul class="org-ul">
<li>Use the valid bit in page table</li>
<li>Without demand paging: 
<ul class="org-ul">
<li>Valid bit = 0: page is invalid</li>
<li>Valid bit = 1: page is valid</li>
</ul></li>
<li>With demand paging 
<ul class="org-ul">
<li>Valid bit = 0: page is invalid OR page is on disk</li>
<li>Valid bit = 1: page is valid AND page is in memory</li>
</ul></li>
<li>OS needs additional table: invalid / on-disk?</li>
</ul>


<div class="figure">
<p><img src="files/Week 7/screenshot_2017-04-19_08-29-15.png" alt="screenshot_2017-04-19_08-29-15.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org1489a31" class="outline-4">
<h4 id="org1489a31"><span class="section-number-4">7.1.4</span> Suspending the faulting process</h4>
<div class="outline-text-4" id="text-7-1-4">
<ul class="org-ul">
<li>Invalid bit access generates a trap</li>
<li>As before, save process information in PCB</li>
</ul>
</div>
</div>
<div id="outline-container-orgc470e91" class="outline-4">
<h4 id="orgc470e91"><span class="section-number-4">7.1.5</span> Getting the Page from Disk</h4>
<div class="outline-text-4" id="text-7-1-5">
<ul class="org-ul">
<li>Assume there is at least one free frame</li>
<li>Allocate a free frame to process</li>
<li>Find page on disk, Note: need an extra table for that</li>
<li>Get disk to transfer page from disk to frame</li>
</ul>
</div>
</div>
<div id="outline-container-org68ddbe1" class="outline-4">
<h4 id="org68ddbe1"><span class="section-number-4">7.1.6</span> While the Disk is busy</h4>
<div class="outline-text-4" id="text-7-1-6">
<ul class="org-ul">
<li>Invoke scheduler to run another process</li>
<li>When disk interrupt arrives 
<ul class="org-ul">
<li>Suspend running process</li>
<li>Get back to page fault handling</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge63d0e3" class="outline-4">
<h4 id="orge63d0e3"><span class="section-number-4">7.1.7</span> Completing Page Fault Handling</h4>
<div class="outline-text-4" id="text-7-1-7">
<ul class="org-ul">
<li>Pagetable[pageno].frameno = new frameno</li>
<li>Pagetable[pageno].valid = 1</li>
<li>Set process state to ready</li>
<li>Invoke scheduler</li>
</ul>
</div>
</div>
<div id="outline-container-orgf35a4b8" class="outline-4">
<h4 id="orgf35a4b8"><span class="section-number-4">7.1.8</span> When Process Runs Again</h4>
<div class="outline-text-4" id="text-7-1-8">
<ul class="org-ul">
<li>Restarts the previously faulting instruction</li>
<li>Now finds  
<ul class="org-ul">
<li>Valid bit to be set to 1</li>
<li>Page in corresponding frame in memory</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org17928ac" class="outline-3">
<h3 id="org17928ac"><span class="section-number-3">7.2</span> Page Replacement Policy</h3>
<div class="outline-text-3" id="text-7-2">
<p>
If no free frame available
</p>
<ul class="org-ul">
<li>Pick a frame to be replaced</li>
<li>Invalidate its page table entry (and TLB entry)</li>
<li>You may have to write that frame to disk</li>
<li>Page table has a modified bit 
<ul class="org-ul">
<li>If set, write out page to disk</li>
<li>If not, proceed with page fault handling</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org363462f" class="outline-4">
<h4 id="org363462f"><span class="section-number-4">7.2.1</span> Page Faults and Performance</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>Normal memory access: ~ nanoseconds</li>
<li>Faulting memory access: Disk i/o ~ 10 milliseconds</li>
<li>Too many page faults &rarr; program very slow</li>
<li>Hence, importance of good page replacement</li>
</ul>
<p>
In general, prefer replacing clean over dirty, 1 disk i/o instead of 2
</p>
</div>
</div>
<div id="outline-container-orgd71ddc3" class="outline-4">
<h4 id="orgd71ddc3"><span class="section-number-4">7.2.2</span> Policy Evaluation</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>Pick a “reference string” of page accesses</li>
<li>Pick a certain number of frames</li>
<li>Count the number of page faults 
<ul class="org-ul">
<li>When simulating that reference string</li>
<li>On a machine with that number of frames</li>
<li>Using the specific page replacement policy</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7a07073" class="outline-4">
<h4 id="org7a07073"><span class="section-number-4">7.2.3</span> FIFO</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li>Oldest page is replaced: Age = Time since brought into memory</li>
<li>Easy to implement</li>
<li>Keep a queue of pages</li>
<li>Bring in a page: stick at the end of the queue</li>
<li>Need replacement: pick head of queue</li>
</ul>
<p>
<img src="files/Week 7/screenshot_2017-04-19_08-43-06.png" alt="screenshot_2017-04-19_08-43-06.png" />
12 page faults (not counting initial paging in)
</p>
</div>
</div>
<div id="outline-container-org4a73d70" class="outline-4">
<h4 id="org4a73d70"><span class="section-number-4">7.2.4</span> OPT: Optimal Algorithm</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>Cannot be implemented in general (need to predict the future)</li>
<li>Basis of comparison for others algorithms</li>
</ul>
<p>
Replace the page that will be referenced the furthest in the future.
<img src="files/Week 7/screenshot_2017-04-19_08-45-06.png" alt="screenshot_2017-04-19_08-45-06.png" /> 
6 page faults (not counting initial paging in)
</p>
</div>
</div>
<div id="outline-container-org7ac6bf6" class="outline-4">
<h4 id="org7ac6bf6"><span class="section-number-4">7.2.5</span> LRU: Least Recently Used</h4>
<div class="outline-text-4" id="text-7-2-5">
<p>
<img src="files/Week 7/screenshot_2017-04-19_08-47-29.png" alt="screenshot_2017-04-19_08-47-29.png" />
9 page faults (not counting initial paging in)
</p>
</div>
<div id="outline-container-org51676e5" class="outline-5">
<h5 id="org51676e5"><span class="section-number-5">7.2.5.1</span> Implementation</h5>
<div class="outline-text-5" id="text-7-2-5-1">
<ul class="org-ul">
<li>Can also not be implemented in general</li>
<li>Need to timestamp every memory reference</li>
<li>Too expensive</li>
<li>But can be (well) approximated</li>
</ul>
</div>
</div>
<div id="outline-container-org539b9d5" class="outline-5">
<h5 id="org539b9d5"><span class="section-number-5">7.2.5.2</span> Approximation</h5>
<div class="outline-text-5" id="text-7-2-5-2">
<p>
Reference bit = bit in page table, HW sets bit when page is referenced.
</p>

<ul class="org-ul">
<li>Pick on of the page with reference bit set</li>
<li>Reset all references bits to zero</li>
</ul>

<p>
Better approximation
</p>
<ul class="org-ul">
<li>Periodically 
<ul class="org-ul">
<li>Read out and store all reference bits</li>
<li>Reset all reference bits to zero</li>
</ul></li>
<li>Keep all reference bits for some time</li>
<li>The more bits kept, the better approximation</li>
<li>Replacement: Page with smallest value of reference bit history</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb39979d" class="outline-4">
<h4 id="orgb39979d"><span class="section-number-4">7.2.6</span> FIFO with Second Chance</h4>
<div class="outline-text-4" id="text-7-2-6">
<ul class="org-ul">
<li>As FIFO, but each page gets a second chance</li>
<li>Bring in page: put at tail of queue (as before)</li>
<li>Replacement: 
<ul class="org-ul">
<li>Look at head of queue</li>
<li>If reference bit is 0, replace</li>
<li>While reference bit is 1 <i>* give second chance *</i> 
<ul class="org-ul">
<li>Put at tail of queue</li>
<li>Set reference bit to 0</li>
<li>Look at head of queue</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgd711ca7" class="outline-5">
<h5 id="orgd711ca7"><span class="section-number-5">7.2.6.1</span> Advantage 1</h5>
<div class="outline-text-5" id="text-7-2-6-1">
<ul class="org-ul">
<li>Combination of 
<ul class="org-ul">
<li>FIFO</li>
<li>LRU approximation with one reference bit</li>
</ul></li>
<li>In LRU approximation with one reference bit: take any page with reference bit
0</li>
<li>Here: Take “oldest” page with reference bit 0</li>
</ul>
</div>
</div>
<div id="outline-container-orgd501d8c" class="outline-5">
<h5 id="orgd501d8c"><span class="section-number-5">7.2.6.2</span> Advantage 2</h5>
<div class="outline-text-5" id="text-7-2-6-2">
<ul class="org-ul">
<li>Combination of 
<ul class="org-ul">
<li>FIFO</li>
<li>LRU approximation with one reference bit</li>
</ul></li>
<li>In LRU approximation with one reference bit: Set all ref bits to 0</li>
<li>Here: Set ref bits of “old” pages to 0</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9c1af41" class="outline-4">
<h4 id="org9c1af41"><span class="section-number-4">7.2.7</span> Clock</h4>
<div class="outline-text-4" id="text-7-2-7">
<ul class="org-ul">
<li>Imagine pages arranged around a clock</li>
<li>Replacement: 
<ul class="org-ul">
<li>Look at page where hand of clock is</li>
<li>If reference bit = 0, replace</li>
<li>If reference bit = 1 
<ul class="org-ul">
<li>Set reference bit to 0</li>
<li>Move hand of clock to next page</li>
</ul></li>
<li>Insert new page where old one was replaced</li>
</ul></li>
</ul>


<div class="figure">
<p><img src="files/Week 7/screenshot_2017-04-19_08-54-40.png" alt="screenshot_2017-04-19_08-54-40.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orga6b68fb" class="outline-4">
<h4 id="orga6b68fb"><span class="section-number-4">7.2.8</span> Clock vs FIFO + Second Chance</h4>
<div class="outline-text-4" id="text-7-2-8">
<ul class="org-ul">
<li>The two are the same policy: The clock points points to the head of the queue</li>
<li>Clock is more efficient 
<ul class="org-ul">
<li>Doesn’t need to move pages around in queue</li>
<li>Instead, clock hand moves</li>
</ul></li>
<li>Works well + efficient to implement: Variations used in many systems (e.g.,
Linux)</li>
</ul>
</div>
</div>
<div id="outline-container-orgd4cd4de" class="outline-4">
<h4 id="orgd4cd4de"><span class="section-number-4">7.2.9</span> Comparisons of Replacement Policies</h4>
<div class="outline-text-4" id="text-7-2-9">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Policy</th>
<th scope="col" class="org-left">Implementation</th>
<th scope="col" class="org-left">Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Random</td>
<td class="org-left">Easy</td>
<td class="org-left">Poor</td>
</tr>

<tr>
<td class="org-left">FIFO</td>
<td class="org-left">Easy (queue)</td>
<td class="org-left">Poor</td>
</tr>

<tr>
<td class="org-left">OPT</td>
<td class="org-left">Impossible</td>
<td class="org-left">Optimal</td>
</tr>

<tr>
<td class="org-left">LRU</td>
<td class="org-left">Difficult (timestamp)</td>
<td class="org-left">Good</td>
</tr>

<tr>
<td class="org-left">LRU approximation</td>
<td class="org-left">Moderate (ref bits)</td>
<td class="org-left">Good (depending on approx.)</td>
</tr>

<tr>
<td class="org-left">FIFO with 2nd Chance</td>
<td class="org-left">Easy</td>
<td class="org-left">Good</td>
</tr>

<tr>
<td class="org-left">Clock</td>
<td class="org-left">Easy and efficient</td>
<td class="org-left">Good</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orge91444f" class="outline-3">
<h3 id="orge91444f"><span class="section-number-3">7.3</span> Frame Allocation</h3>
<div class="outline-text-3" id="text-7-3">
<p>
How many frame to give to each process?
</p>
</div>
<div id="outline-container-org2268c29" class="outline-4">
<h4 id="org2268c29"><span class="section-number-4">7.3.1</span> Degree of Multiprocessing</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>How many processes to keep in memory?</li>
<li>Without demand paging: 
<ul class="org-ul">
<li>All of process must be in memory</li>
<li>Severely limits degree of multiprocessing</li>
</ul></li>
<li>With demand paging: 
<ul class="org-ul">
<li>Only part of process must be in memory</li>
<li>Can achieve high degree of multiprocessing</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge3766a5" class="outline-4">
<h4 id="orge3766a5"><span class="section-number-4">7.3.2</span> Link between deg of multproc and page fault rate</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>Give each process frames for  ~ all of its pages 
<ul class="org-ul">
<li>Low degree of multiprocessing</li>
<li>Few page faults</li>
<li>Slow switching on i/o</li>
</ul></li>
<li>Give each process 1 frame 
<ul class="org-ul">
<li>High degree of multiprocessing</li>
<li>Many page faults ( thrashing)</li>
<li>Quick switching on i/o</li>
</ul></li>
<li>Where is the correct tradeoff?</li>
</ul>
</div>
</div>
<div id="outline-container-org001f79e" class="outline-4">
<h4 id="org001f79e"><span class="section-number-4">7.3.3</span> Working Set of a Process</h4>
<div class="outline-text-4" id="text-7-3-3">
<ul class="org-ul">
<li>Set of pages of process needed for execution</li>
<li>Intuition:  
<ul class="org-ul">
<li>Working set not in memory  &rarr;  many page faults</li>
<li>Working set in memory  &rarr;  no page faults</li>
<li>More than working set in memory  &rarr;  no gain</li>
</ul></li>
</ul>
<p>
Working set &lt; all pages?
</p>
<ul class="org-ul">
<li>Principle of locality</li>
<li>In given time interval:
<ul class="org-ul">
<li>Process only access part of its pages</li>
<li>Example: intialization, main, termination, error, &#x2026;</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgceb769c" class="outline-4">
<h4 id="orgceb769c"><span class="section-number-4">7.3.4</span> Tradeoff</h4>
<div class="outline-text-4" id="text-7-3-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Frame allocation</th>
<th scope="col" class="org-left">Page Faults</th>
<th scope="col" class="org-left">Degree of Multiprocessing</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">All frames</td>
<td class="org-left">None</td>
<td class="org-left">Low</td>
</tr>

<tr>
<td class="org-left">1 frame</td>
<td class="org-left">Many</td>
<td class="org-left">High</td>
</tr>

<tr>
<td class="org-left">Working Set</td>
<td class="org-left">Few</td>
<td class="org-left">Moderate</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org7a960d9" class="outline-4">
<h4 id="org7a960d9"><span class="section-number-4">7.3.5</span> Frame Allocation Policy</h4>
<div class="outline-text-4" id="text-7-3-5">
<ul class="org-ul">
<li>Give each process enough frames to maintain its working set in memory</li>
<li>If sum of all working sets &gt; memory, swap out one or more processes</li>
<li>If sum of all working sets &lt; memory, swap in one or more processes</li>
</ul>
</div>
</div>
<div id="outline-container-org86917b2" class="outline-4">
<h4 id="org86917b2"><span class="section-number-4">7.3.6</span> How to Predict Working Set?</h4>
<div class="outline-text-4" id="text-7-3-6">
<ul class="org-ul">
<li>Working set for next 10’000 refs = working set for last 10’000 refs</li>
<li>Prediction is not perfect 
<ul class="org-ul">
<li>Phase change (e.g., from initialization to main)</li>
<li>Will decrease during next phase</li>
<li>Will cause (temporary) high page fault rate</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgba23fa7" class="outline-5">
<h5 id="orgba23fa7"><span class="section-number-5">7.3.6.1</span> Past Working Set measurement</h5>
<div class="outline-text-5" id="text-7-3-6-1">
<ul class="org-ul">
<li>We do not really need working set</li>
<li>We only need working set size</li>
<li>Periodically (every 10’000 references) 
<ul class="org-ul">
<li>Count reference bits set to 1</li>
<li>Set all references bits to 0</li>
</ul></li>
<li>Working set (for last 10’000 references) = number of reference bits set to 1</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8496384" class="outline-4">
<h4 id="org8496384"><span class="section-number-4">7.3.7</span> Page Replacement vs Frame Allocation</h4>
<div class="outline-text-4" id="text-7-3-7">
<ul class="org-ul">
<li>Frame allocation done periodically</li>
<li>Page replacement done at page fault time</li>
</ul>
</div>
</div>
<div id="outline-container-org51ad9c0" class="outline-4">
<h4 id="org51ad9c0"><span class="section-number-4">7.3.8</span> Global vs Local Replacement</h4>
<div class="outline-text-4" id="text-7-3-8">
<ul class="org-ul">
<li>Local replacement: replace page of faulting process</li>
<li>Global replacement: replace any page</li>
<li>Done according to page replacement</li>
<li>E.g., FIFO: 
<ul class="org-ul">
<li>Local: replace oldest page of faulting process</li>
<li>Global: pick the oldest page overall</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0a2f683" class="outline-4">
<h4 id="org0a2f683"><span class="section-number-4">7.3.9</span> Tradeoff: Local - Global</h4>
<div class="outline-text-4" id="text-7-3-9">
<ul class="org-ul">
<li>Assume using working set for frame allocation</li>
<li>Local: 
<ul class="org-ul">
<li>You cannot affect anyone else’s working set</li>
<li>Hence, you cannot cause thrashing of others</li>
<li>But inflexible for yourself</li>
<li>If working set grows, cannot react</li>
<li>Hence, you can cause yourself to trash</li>
</ul></li>
<li>Global: 
<ul class="org-ul">
<li>You can affect others’ working set</li>
<li>Hence, you cause thrashing of others</li>
<li>But flexible for yourself</li>
<li>If working set grows, can react</li>
<li>Hence, you can avoid yourself to trash</li>
</ul></li>
<li>Use frame allocation periodically</li>
<li>Use local replacement in-between</li>
<li>You may trash for a short time</li>
<li>But at next period get bigger allocation, so OK</li>
<li>Cannot cause thrashing of others, so OK</li>
</ul>
</div>
</div>
<div id="outline-container-org48b82b1" class="outline-4">
<h4 id="org48b82b1"><span class="section-number-4">7.3.10</span> Frame Allocation Driving Page Replacement</h4>
<div class="outline-text-4" id="text-7-3-10">
<ul class="org-ul">
<li>Periodically run working set computation</li>
<li>If allocation &gt; working set</li>
<li>Immediately replace non-WS pages</li>
<li>Or favor them during later replacement</li>
<li>Algorithm: WSClock does this (not covered)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2fa4c05" class="outline-3">
<h3 id="org2fa4c05"><span class="section-number-3">7.4</span> Optimization</h3>
<div class="outline-text-3" id="text-7-4">
</div><div id="outline-container-org582afd1" class="outline-4">
<h4 id="org582afd1"><span class="section-number-4">7.4.1</span> Prepaging</h4>
<div class="outline-text-4" id="text-7-4-1">
<ul class="org-ul">
<li>So far: page in 1 page at time</li>
<li>Prepaging: page in multiple pages at a time</li>
<li>Usually, pages “surrounding” faulting page</li>
</ul>
</div>
<div id="outline-container-org65fd508" class="outline-5">
<h5 id="org65fd508"><span class="section-number-5">7.4.1.1</span> Performance</h5>
<div class="outline-text-5" id="text-7-4-1-1">
<ul class="org-ul">
<li>Relies on locality of virtual memory access, nearby pages are often accessed
soon after</li>
<li>Avoids page faults, process switches, ..</li>
<li>Can also get better disk performance (later)</li>
<li>May bring in unnecessary pages</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5272a2d" class="outline-4">
<h4 id="org5272a2d"><span class="section-number-4">7.4.2</span> Cleaning</h4>
<div class="outline-text-4" id="text-7-4-2">
<ul class="org-ul">
<li>So far: prefer to replace “clean” pages</li>
<li>Cleaning: disk idle, write out “dirty” pages</li>
</ul>
</div>
<div id="outline-container-orgba244ba" class="outline-5">
<h5 id="orgba244ba"><span class="section-number-5">7.4.2.1</span> Performance</h5>
<div class="outline-text-5" id="text-7-4-2-1">
<ul class="org-ul">
<li>More “clean” pages at replacement time: quicker replacement</li>
<li>But page may be modified again: useless disk traffic</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org70cb247" class="outline-4">
<h4 id="org70cb247"><span class="section-number-4">7.4.3</span> Free Frame Pool</h4>
<div class="outline-text-4" id="text-7-4-3">
<ul class="org-ul">
<li>So far: use all possible frames for pages</li>
<li>Free pool: keep some frames unused</li>
</ul>
</div>
<div id="outline-container-org442ecef" class="outline-5">
<h5 id="org442ecef"><span class="section-number-5">7.4.3.1</span> Performance</h5>
<div class="outline-text-5" id="text-7-4-3-1">
<ul class="org-ul">
<li>Page fault handling is quick</li>
<li>Reduces effective main memory size</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgeef5639" class="outline-4">
<h4 id="orgeef5639"><span class="section-number-4">7.4.4</span> Copy -on-Write</h4>
<div class="outline-text-4" id="text-7-4-4">
<ul class="org-ul">
<li>Clever trick for sharing pages between processes 
<ul class="org-ul">
<li>That are initially the same</li>
<li>That are likely to be read-only</li>
<li>But that may (unlikely) be modified by a process</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org453b995" class="outline-5">
<h5 id="org453b995"><span class="section-number-5">7.4.4.1</span> Read-Only Sharing</h5>
<div class="outline-text-5" id="text-7-4-4-1">
<ul class="org-ul">
<li>Make page table entry point to same frame</li>
<li>Set read-only bit so trap if process writes</li>
<li>Trap treated as illegal memory access</li>
</ul>
</div>
</div>
<div id="outline-container-org3ec1b51" class="outline-5">
<h5 id="org3ec1b51"><span class="section-number-5">7.4.4.2</span> Implementation</h5>
<div class="outline-text-5" id="text-7-4-4-2">
<ul class="org-ul">
<li>Make page table entry point to same frame</li>
<li>Set read-only bit so trap if process writes</li>
<li>Fault not treated as illegal memory access</li>
<li>Instead: 
<ul class="org-ul">
<li>Create separate frame for faulting process</li>
<li>Insert (pageno, frameno) in page table</li>
<li>Set read-only bit to off (i.e., read-write)</li>
<li>Copy page into that frame</li>
</ul></li>
<li>Further accesses will not page fault</li>
</ul>
</div>
</div>
<div id="outline-container-org420cd9a" class="outline-5">
<h5 id="org420cd9a"><span class="section-number-5">7.4.4.3</span> Performance</h5>
<div class="outline-text-5" id="text-7-4-4-3">
<ul class="org-ul">
<li>Works well if page is rarely written, save frames (as many as sharers - 1)</li>
<li>Works poorly if page is often written, more page faults, don't gain in frame
occupation</li>
</ul>
</div>
</div>
<div id="outline-container-org9f1ad0a" class="outline-5">
<h5 id="org9f1ad0a"><span class="section-number-5">7.4.4.4</span> In practice</h5>
<div class="outline-text-5" id="text-7-4-4-4">
<ul class="org-ul">
<li>The conditions under which copy-on-write works well occur in practice</li>
<li>All OS’s provide it</li>
<li>This is how Linux implements fork()</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd8f7e89" class="outline-2">
<h2 id="orgd8f7e89"><span class="section-number-2">8</span> Week 8</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-org105c0b3" class="outline-3">
<h3 id="org105c0b3"><span class="section-number-3">8.1</span> Files and type</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-org714f35b" class="outline-4">
<h4 id="org714f35b"><span class="section-number-4">8.1.1</span> File</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Un-interpreted collection of objects
</p>
<ul class="org-ul">
<li>File System does not know what data means</li>
<li>Only application knows</li>
<li>Objects = byte, records, &#x2026;</li>
</ul>
</div>
</div>
<div id="outline-container-orgfe4eb8e" class="outline-4">
<h4 id="orgfe4eb8e"><span class="section-number-4">8.1.2</span> Type or untyped</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
Typed = FS knows what the object means
</p>

<p>
Advantages:
</p>
<ul class="org-ul">
<li>Invoke certain programs by default</li>
<li>Prevent errors</li>
<li>More efficient storage</li>
</ul>
<p>
Disadvantages
</p>
<ul class="org-ul">
<li>Can be inflexible (typecast)</li>
<li>Can become a lot of code (many types)</li>
</ul>
<p>
We look at untyped
</p>
</div>
</div>
</div>
<div id="outline-container-org5c30f32" class="outline-3">
<h3 id="org5c30f32"><span class="section-number-3">8.2</span> File System Primitives</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-orgd7d3c98" class="outline-4">
<h4 id="orgd7d3c98"><span class="section-number-4">8.2.1</span> Acesss</h4>
<div class="outline-text-4" id="text-8-2-1">
</div><div id="outline-container-orgff4f702" class="outline-5">
<h5 id="orgff4f702"><span class="section-number-5">8.2.1.1</span> Create() and Delete()</h5>
<div class="outline-text-5" id="text-8-2-1-1">
<ul class="org-ul">
<li>uid = Create([optional arguments])
<ul class="org-ul">
<li><i>uid</i> unique identifier, not human-readable string</li>
<li>Creates an empty file</li>
</ul></li>
<li>Delete(uid)
<ul class="org-ul">
<li>Deletes file with identifier <i>uid</i></li>
<li>Usually also deletes all of its content</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0b51452" class="outline-5">
<h5 id="org0b51452"><span class="section-number-5">8.2.1.2</span> Read()</h5>
<div class="outline-text-5" id="text-8-2-1-2">
<p>
Read(uid, buffer, from, to)
</p>
<ul class="org-ul">
<li>Reads from file with identifier <i>uid</i></li>
<li>From byte <i>from</i> to byte <i>to</i> &rarr; can cause EOF condition</li>
<li>Into a memory buffer <i>buffer</i>
<ul class="org-ul">
<li>previously allocated</li>
<li>must be of sufficient size</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf2121db" class="outline-5">
<h5 id="orgf2121db"><span class="section-number-5">8.2.1.3</span> Write()</h5>
<div class="outline-text-5" id="text-8-2-1-3">
<p>
Write(uid, buffer, from to)
</p>
<ul class="org-ul">
<li>Write to file with identifier <i>uid</i></li>
<li>Into byte <i>from</i> to byte <i>to</i></li>
<li>From a memory buffer <i>buffer</i></li>
</ul>
</div>
</div>
<div id="outline-container-org3d7449c" class="outline-5">
<h5 id="org3d7449c"><span class="section-number-5">8.2.1.4</span> Sequential vs Random Access</h5>
<div class="outline-text-5" id="text-8-2-1-4">
<ul class="org-ul">
<li>Read() and Write() = Random-access primitives, no connection between two
successive accesses</li>
<li>Sequential access is very common
<ul class="org-ul">
<li>Read from where you stopped reading</li>
<li>Write to where you stopped writing</li>
<li>In particular, whole file access is common</li>
</ul></li>
<li>We thus need sequential access methods</li>
</ul>
</div>
</div>
<div id="outline-container-org3c38217" class="outline-5">
<h5 id="org3c38217"><span class="section-number-5">8.2.1.5</span> Sequential Read()</h5>
<div class="outline-text-5" id="text-8-2-1-5">
<ul class="org-ul">
<li>File system keeps file pointer <i>fp</i> (initially 0)</li>
<li>Read(uid, buffer, bytes)
<ul class="org-ul">
<li>Read from file with unique identifier <i>uid</i></li>
<li>Starting from byte <i>fp</i></li>
<li><i>Bytes</i> bytes</li>
<li>Into memory buffer <i>buffer</i></li>
<li><i>fp</i> += <i>bytes</i></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6fd0b9c" class="outline-5">
<h5 id="org6fd0b9c"><span class="section-number-5">8.2.1.6</span> Sequential from random</h5>
<div class="outline-text-5" id="text-8-2-1-6">
<ul class="org-ul">
<li>Maintain <i>fp</i>-equivalent in user code</li>
<li><i>myfp</i> = 0</li>
<li>Read(uid, buffer, myfp, myfp+bytes-1)</li>
<li><i>myfp</i> += <i>bytes</i></li>
<li>Read(uid, buffer, myfp, myfp+bytes-1)</li>
</ul>
</div>
</div>
<div id="outline-container-org2eb0bec" class="outline-5">
<h5 id="org2eb0bec"><span class="section-number-5">8.2.1.7</span> Random from sequential</h5>
<div class="outline-text-5" id="text-8-2-1-7">
<ul class="org-ul">
<li>Need to have another primitive Seek(uid, to) (fp = to)</li>
<li>Implementation
<ul class="org-ul">
<li>Read(uid, from, to, buffer)</li>
<li>Seek(uid, from)</li>
<li>Read(uid, buffer, to-from+1)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3c28cd8" class="outline-5">
<h5 id="org3c28cd8"><span class="section-number-5">8.2.1.8</span> Random vs Sequential</h5>
<div class="outline-text-5" id="text-8-2-1-8">
<ul class="org-ul">
<li>Sequential access is very common</li>
<li>All systems provide sequential access</li>
<li>Some systems provide only sequential access + Seek()</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org730c3a4" class="outline-4">
<h4 id="org730c3a4"><span class="section-number-4">8.2.2</span> Concurrency</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
Two processes access the same file, what about <i>fp</i>?
</p>
</div>
<div id="outline-container-org1c6af61" class="outline-5">
<h5 id="org1c6af61"><span class="section-number-5">8.2.2.1</span> Open a file with Open() and Close()</h5>
<div class="outline-text-5" id="text-8-2-2-1">
<ul class="org-ul">
<li>tid = Open(uid, [optional args])
<ul class="org-ul">
<li>Creates an instance of file with <i>uid</i></li>
<li>Accessible by this process only</li>
<li>With the temporary process-unique id <i>tid</i></li>
<li><i>fp</i> is associated with <i>tid</i>, not with <i>uid</i></li>
</ul></li>
<li>Close(tid) &rarr; destroys the instance</li>
</ul>
</div>
</div>
<div id="outline-container-org9f518c8" class="outline-5">
<h5 id="org9f518c8"><span class="section-number-5">8.2.2.2</span> Open() with Read()</h5>
<div class="outline-text-5" id="text-8-2-2-2">
<ul class="org-ul">
<li>tid = Open()</li>
<li>Read(tid, buffer, bytes)</li>
<li>Other Read()s or Write()s</li>
<li>&#x2026;</li>
<li>Close(tid)</li>
</ul>
</div>
</div>
<div id="outline-container-orgc31a27b" class="outline-5">
<h5 id="orgc31a27b"><span class="section-number-5">8.2.2.3</span> Semantic of Concurrent Open()s</h5>
<div class="outline-text-5" id="text-8-2-2-3">
<ul class="org-ul">
<li>Separate instances altogether &rarr; Write()s by one not visible to
others</li>
<li>Separate instances until Close() &rarr; Write()s visible after Close()</li>
<li>One single instance of the file &rarr; Write()s visible immediately to
others</li>
<li><i>fp</i> is private!</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc259ad4" class="outline-4">
<h4 id="orgc259ad4"><span class="section-number-4">8.2.3</span> Naming</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>Naming = mapping, from human-readable string &rarr; uid</li>
<li>Directory = collection of such mappings</li>
</ul>
</div>
<div id="outline-container-org72ac2dd" class="outline-5">
<h5 id="org72ac2dd"><span class="section-number-5">8.2.3.1</span> Directory Structures</h5>
<div class="outline-text-5" id="text-8-2-3-1">
<ul class="org-ul">
<li>Flat</li>
<li>Two-level: [user] filename</li>
<li>Hierarchical: <i>a/b/c</i>&#x2026;
<ul class="org-ul">
<li>Root directory</li>
<li>Working directory</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgca90164" class="outline-5">
<h5 id="orgca90164"><span class="section-number-5">8.2.3.2</span> Naming primitives</h5>
<div class="outline-text-5" id="text-8-2-3-2">
<ul class="org-ul">
<li>Insert(string, uid)</li>
<li>uid = Lookup(string)</li>
<li>Remove(string, uid)</li>
</ul>
</div>
</div>
<div id="outline-container-orgef73dae" class="outline-5">
<h5 id="orgef73dae"><span class="section-number-5">8.2.3.3</span> Directory Primitives</h5>
<div class="outline-text-5" id="text-8-2-3-3">
<ul class="org-ul">
<li>CreateDirectory (string)</li>
<li>DeleteDirectory(string)</li>
<li>SetWorkingDirectory(string)</li>
<li>string = ListWorkingDirectory()</li>
<li>List(directory)</li>
</ul>
</div>
</div>
<div id="outline-container-org0f36407" class="outline-5">
<h5 id="org0f36407"><span class="section-number-5">8.2.3.4</span> Hierarchical Directory Structures</h5>
<div class="outline-text-5" id="text-8-2-3-4">
<ul class="org-ul">
<li>Tree</li>
<li>(Acyclic) Graph &rarr; allows sharing of two <i>uids</i> under different names</li>
</ul>
</div>
</div>
<div id="outline-container-org2e3e2b1" class="outline-5">
<h5 id="org2e3e2b1"><span class="section-number-5">8.2.3.5</span> Hard Link</h5>
<div class="outline-text-5" id="text-8-2-3-5">
<ul class="org-ul">
<li>Assume mapping (string1, uid) already exists</li>
<li>Hardlink(string2, uid)</li>
<li>Insert(string2, uid)</li>
<li>After Hardlink, two mappings are equivalent</li>
</ul>
</div>
</div>
<div id="outline-container-org65ae45c" class="outline-5">
<h5 id="org65ae45c"><span class="section-number-5">8.2.3.6</span> Soft Link</h5>
<div class="outline-text-5" id="text-8-2-3-6">
<ul class="org-ul">
<li>Assume mapping (string1, uid) exists</li>
<li>SoftLink(string2, string1)</li>
<li>Insert(string2, string1)</li>
<li>After Softlink, two mappings are different</li>
</ul>
</div>
</div>
<div id="outline-container-org99acea9" class="outline-5">
<h5 id="org99acea9"><span class="section-number-5">8.2.3.7</span> Hard/Soft Link differences</h5>
<div class="outline-text-5" id="text-8-2-3-7">
<p>
After remove(String1, uid), in the case of a hard link, the mapping (string2,
uid) remains, in the case of a soft link, the mapping (string2, string1) is a
dangling reference.
</p>

<ul class="org-ul">
<li>HardLink is a mapping to a <b>file</b></li>
<li>SoftLink is a mapping to a <b>string</b></li>
</ul>
</div>
</div>
<div id="outline-container-org4376974" class="outline-5">
<h5 id="org4376974"><span class="section-number-5">8.2.3.8</span> Acyclic Graph</h5>
<div class="outline-text-5" id="text-8-2-3-8">
<p>
Why?
</p>
<ul class="org-ul">
<li>(Later) disk storage reclamation by refcounts</li>
<li>Cycles cause waster disk space</li>
</ul>
<p>
How?
</p>
<ul class="org-ul">
<li>Soft links cannot make cycles</li>
<li>Hard links can make cycles</li>
<li>Do not allow hard links to directories, only to leafs in the graph</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org30dd232" class="outline-4">
<h4 id="org30dd232"><span class="section-number-4">8.2.4</span> Linux Primitives</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>Collapses in a single interface access, concurrency and naming</li>
<li>Creat(string)
<ul class="org-ul">
<li>uid = Create()</li>
<li>Insert(string, uid)</li>
</ul></li>
<li>fd = Open(string, [optional args])
<ul class="org-ul">
<li>uid = Lookup(string)</li>
<li>fd = (tid =) Open(uid, [optional args])</li>
</ul></li>
<li>&#x2026;</li>
<li><i>uid</i> is never visible at the user level</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org049120e" class="outline-3">
<h3 id="org049120e"><span class="section-number-3">8.3</span> Disk terminology</h3>
<div class="outline-text-3" id="text-8-3">

<div class="figure">
<p><img src="files/Week 8/screenshot_2017-05-21_11-18-21.png" alt="screenshot_2017-05-21_11-18-21.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgd681f13" class="outline-3">
<h3 id="orgd681f13"><span class="section-number-3">8.4</span> Disk Interface</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>Accessible by sector only</li>
<li>ReadSector( logical<sub>sector</sub><sub>number</sub>, buffer)</li>
<li>WriteSector( logical<sub>sector</sub><sub>number</sub>, buffer)</li>
<li>Logival<sub>sectore</sub><sub>number</sub> = 
<ul class="org-ul">
<li>Platter</li>
<li>Cylinder or track</li>
<li>Sector</li>
</ul></li>
</ul>
<p>
Main task of the file system is to translate from user interface methods
(Read(uid&#x2026;)) to disk interface methods (ReadSector(logical<sub>sector</sub><sub>number</sub>&#x2026;))
</p>
</div>
<div id="outline-container-orgdb2fd3a" class="outline-4">
<h4 id="orgdb2fd3a"><span class="section-number-4">8.4.1</span> Simplifications</h4>
<div class="outline-text-4" id="text-8-4-1">
<ol class="org-ol">
<li>User Read() allows arbitrary number of bytes
<ul class="org-ul">
<li>Simply to only allowing Read() of a block (Read(uid, block<sub>number</sub>))</li>
<li>A block is fixed-size</li>
</ul></li>
<li>Block size = sector size
<ul class="org-ul">
<li>Typically, block size = 2<sup>n</sup> * sector size</li>
<li>For example, block size = 4096B, sector size = 512B</li>
</ul></li>
</ol>
<p>
Simplifications are easily implemented in the library
</p>
</div>
</div>
</div>
<div id="outline-container-org57fddf4" class="outline-3">
<h3 id="org57fddf4"><span class="section-number-3">8.5</span> Disk Access</h3>
<div class="outline-text-3" id="text-8-5">
<p>
Disk access time:
</p>
<ul class="org-ul">
<li>Head selection, selects a platter
<ul class="org-ul">
<li>Electronic switch</li>
<li>Nanoseconds</li>
</ul></li>
<li>Seek, move an arm over cylinder
<ul class="org-ul">
<li>Approximately linear in the number of cylinders</li>
<li>3-12 ms</li>
</ul></li>
<li>Rotational latency, move head over sector
<ul class="org-ul">
<li>Linear in the number of sectors</li>
<li>Rotational speed: 4500-15000 RPM</li>
<li>One revolution = 1/(RPM/60) seconds</li>
<li>Average rotational latency = 1/2 revolution</li>
<li>From 2 to 7.1 ms</li>
</ul></li>
<li>Transfer time, read from sector
<ul class="org-ul">
<li>Effective transfer rate ~ 1GB/s</li>
<li>Sector = 512B</li>
<li>~ 0.5 &mu; s</li>
</ul></li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Component</th>
<th scope="col" class="org-left">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Head Selection</td>
<td class="org-left">nanoseconds</td>
</tr>

<tr>
<td class="org-left">Seek Time</td>
<td class="org-left">3-12 milliseconds</td>
</tr>

<tr>
<td class="org-left">Rotational latency</td>
<td class="org-left">2-7 milliseconds</td>
</tr>

<tr>
<td class="org-left">Transfer Time</td>
<td class="org-left">microseconds</td>
</tr>

<tr>
<td class="org-left">Controller Overhead</td>
<td class="org-left">&lt; 1 milliseconds</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Disk access time &gt;&gt; memory access time</li>
<li>Seek time dominates</li>
<li>Followed by rotational latency</li>
</ul>
</div>
<div id="outline-container-org816faf4" class="outline-4">
<h4 id="org816faf4"><span class="section-number-4">8.5.1</span> Optimization: File System Cache (Buffer Cache)</h4>
<div class="outline-text-4" id="text-8-5-1">
<ul class="org-ul">
<li>Rule 1: Do not access disk</li>
<li>use a cache</li>
</ul>
</div>

<div id="outline-container-orgd5ce974" class="outline-5">
<h5 id="orgd5ce974"><span class="section-number-5">8.5.1.1</span> FS cache</h5>
<div class="outline-text-5" id="text-8-5-1-1">
<ul class="org-ul">
<li>Keeps recently accessed blocks in memory</li>
<li>reduces latency and disk load</li>
<li>Need to reverse kernel memory for cache, cache entries = files blocks (of
block size)</li>
</ul>
</div>
</div>

<div id="outline-container-org7c4beaf" class="outline-5">
<h5 id="org7c4beaf"><span class="section-number-5">8.5.1.2</span> Read with a Cache</h5>
<div class="outline-text-5" id="text-8-5-1-2">
<ul class="org-ul">
<li>If in cache, return data from cache</li>
<li>If not
<ul class="org-ul">
<li>Find free cache slot</li>
<li>Initiate disk read</li>
<li>When disk read completes, return data</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org92578ce" class="outline-5">
<h5 id="org92578ce"><span class="section-number-5">8.5.1.3</span> Write with a Cache</h5>
<div class="outline-text-5" id="text-8-5-1-3">
<ul class="org-ul">
<li>Always write in cache</li>
<li>Write-Through = write directly to disk</li>
<li>Write-behind = write later to disk</li>
</ul>
<p>
Write-Through vs Write-Behind
</p>
<ul class="org-ul">
<li>Response time: write-behind is (much) better</li>
<li>Disk load
<ul class="org-ul">
<li>Write-behind is (much) better</li>
<li>Much data overwritten before it gets tot disk</li>
</ul></li>
<li>Crash
<ul class="org-ul">
<li>Write through is much better</li>
<li>no "window of vulnerability"</li>
</ul></li>
</ul>
<p>
In practice
</p>
<ul class="org-ul">
<li>Write-behind</li>
<li>Periodic cache flush</li>
<li>User primitive to flush data</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga1c3027" class="outline-4">
<h4 id="orga1c3027"><span class="section-number-4">8.5.2</span> Optimization: Read-Ahead</h4>
<div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>Rule 2: Don't wait for disk</li>
<li>Read-ahead (or prefetching)</li>
<li>Only for sequential access)</li>
</ul>
</div>
<div id="outline-container-org582f4de" class="outline-5">
<h5 id="org582f4de"><span class="section-number-5">8.5.2.1</span> Read-Ahead</h5>
<div class="outline-text-5" id="text-8-5-2-1">
<ul class="org-ul">
<li>User request for block i of a file, also read block i+1 form disk</li>
<li>Need to put block i+1 in the buffer cache</li>
<li>This way, no disk I/O on (expected) user access to block i+1</li>
<li>Works for sequential access (most access is), in Linux = default</li>
</ul>
</div>
</div>
<div id="outline-container-orgc1e4151" class="outline-5">
<h5 id="orgc1e4151"><span class="section-number-5">8.5.2.2</span> Caveat</h5>
<div class="outline-text-5" id="text-8-5-2-2">
<ul class="org-ul">
<li>Does not reduce number of disk I/Os</li>
<li>In fact, could increase them (if not sequential)</li>
<li>In practice, very often a win, Linux always reads one block ahead</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8937137" class="outline-4">
<h4 id="org8937137"><span class="section-number-4">8.5.3</span> Optimization: minimize seeks</h4>
<div class="outline-text-4" id="text-8-5-3">
</div><div id="outline-container-orge3b76c5" class="outline-5">
<h5 id="orge3b76c5"><span class="section-number-5">8.5.3.1</span> Clever disk allocation</h5>
<div class="outline-text-5" id="text-8-5-3-1">
<p>
Locate related data (same file) on same cylinder
</p>
<ul class="org-ul">
<li>allocate "related" blocks "together"</li>
<li>"together" = on the same/nearby cylinder</li>
<li>"related" = consecutive blocks in the same file, seq. access</li>
</ul>
</div>
</div>
<div id="outline-container-orgf020d51" class="outline-5">
<h5 id="orgf020d51"><span class="section-number-5">8.5.3.2</span> Clever scheduling</h5>
<div class="outline-text-5" id="text-8-5-3-2">
<p>
Reorder requests to seek as little as possible &rarr; also minimize seeks
</p>
<ul class="org-ul">
<li>FCFS: next request in queue</li>
<li>SSTF: pick "nearest" request in queue
<ul class="org-ul">
<li>Very good seek times</li>
<li>Subject to starvation, request on inside or outside can get starved</li>
</ul></li>
<li>SCAN
<ul class="org-ul">
<li>Continue moving head in one direcion
<ul class="org-ul">
<li>From 0 to MAX<sub>CYL</sub></li>
<li>Then, from MAX<sub>CYL</sub> to 0</li>
</ul></li>
<li>Pick requests as you move head</li>
</ul></li>
<li>C-SCAN
<ul class="org-ul">
<li>Similar to SCAN</li>
<li>Always move head
<ul class="org-ul">
<li>From 0 to MAX<sub>CYL</sub>; pick up requests as head moves</li>
<li>From MAX<sub>CYL</sub> to 0; no request served</li>
</ul></li>
<li>Number of cylinders slightly higher</li>
<li>More uniform wait time</li>
</ul></li>
<li>C-LOOK
<ul class="org-ul">
<li>Similar to C-SCAN</li>
<li>Always move head
<ul class="org-ul">
<li>From min<sub>cyl</sub> to max<sub>cyl</sub>; serve requests as head moves</li>
<li>From max<sub>cyl</sub> to min<sub>cyl</sub>; no requests served</li>
</ul></li>
</ul></li>
</ul>
<p>
In practice, variation of C-LOOK
</p>
</div>
</div>
</div>
<div id="outline-container-orgc5f6a17" class="outline-4">
<h4 id="orgc5f6a17"><span class="section-number-4">8.5.4</span> Optimization: Avoid rotational latency</h4>
<div class="outline-text-4" id="text-8-5-4">
<ul class="org-ul">
<li>Clever disk allocation</li>
<li>Locate consecutive blocks of file on consecutive sectors in a cylinder</li>
</ul>
</div>
</div>
<div id="outline-container-org50ef3f7" class="outline-4">
<h4 id="org50ef3f7"><span class="section-number-4">8.5.5</span> When does what works well?</h4>
<div class="outline-text-4" id="text-8-5-5">
</div><div id="outline-container-org28d4fc1" class="outline-5">
<h5 id="org28d4fc1"><span class="section-number-5">8.5.5.1</span> High load</h5>
<div class="outline-text-5" id="text-8-5-5-1">
<p>
Disk scheduling works well
</p>
<ul class="org-ul">
<li>Many scheduling opportunities, many requests in the queue</li>
<li>Allocation gets defeated by interleaved requests for different files</li>
</ul>
</div>
</div>
<div id="outline-container-org2237f01" class="outline-5">
<h5 id="org2237f01"><span class="section-number-5">8.5.5.2</span> Low load</h5>
<div class="outline-text-5" id="text-8-5-5-2">
<p>
Clever allocation works well
</p>
<ul class="org-ul">
<li>Not much scheduling opportunity, not many requests in the queue</li>
<li>Sequential user access &rarr; sequential disk access</li>
<li>Cache tends to reduce load</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd6068bf" class="outline-4">
<h4 id="orgd6068bf"><span class="section-number-4">8.5.6</span> Summary</h4>
<div class="outline-text-4" id="text-8-5-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Optimization</th>
<th scope="col" class="org-left">Goal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Caching</td>
<td class="org-left">Avoid disk access</td>
</tr>

<tr>
<td class="org-left">Read-ahead</td>
<td class="org-left">Avoid waiting for disk</td>
</tr>

<tr>
<td class="org-left">Disk allocation</td>
<td class="org-left">Avoid seek and rotational latency</td>
</tr>

<tr>
<td class="org-left">Disk Scheduling</td>
<td class="org-left">Avoid seek</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Disks are random access devices</li>
<li>But, sequential access &gt;&gt; random access (Bandwidth 100x greater for
sequential)</li>
<li>Application should aim for sequential access</li>
<li>System should aim for sequential access</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4bda38a" class="outline-2">
<h2 id="org4bda38a"><span class="section-number-2">9</span> Week 9</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-orgecf7811" class="outline-3">
<h3 id="orgecf7811"><span class="section-number-3">9.1</span> Disk vs In. Memory</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Simple rule: If not on disk and crash, it's gone.
</p>
</div>
</div>
<div id="outline-container-orgdd06cc4" class="outline-3">
<h3 id="orgdd06cc4"><span class="section-number-3">9.2</span> Disk Data Structures</h3>
<div class="outline-text-3" id="text-9-2">
</div><div id="outline-container-org66306f8" class="outline-4">
<h4 id="org66306f8"><span class="section-number-4">9.2.1</span> Boot block</h4>
<div class="outline-text-4" id="text-9-2-1">
<ul class="org-ul">
<li>At fixed location on disk (usually sector 0)</li>
<li>Contains boot loader</li>
<li>Read on machine boot</li>
</ul>
</div>
</div>
<div id="outline-container-org302b8bb" class="outline-4">
<h4 id="org302b8bb"><span class="section-number-4">9.2.2</span> Device Directory</h4>
<div class="outline-text-4" id="text-9-2-2">
<ul class="org-ul">
<li>Fixed, reserved area on disk</li>
<li>Array of records (device directory entry or DDE)</li>
<li>Indexed by <i>uid</i></li>
<li>Record contains:
<ul class="org-ul">
<li>In-use bit (more generally, reference count)</li>
<li>Size</li>
<li>Other info: access rights, etc.</li>
<li>Disk address(es) pointing to file data</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org92776b8" class="outline-4">
<h4 id="org92776b8"><span class="section-number-4">9.2.3</span> User data Allocation</h4>
<div class="outline-text-4" id="text-9-2-3">
</div><div id="outline-container-orgac1e348" class="outline-5">
<h5 id="orgac1e348"><span class="section-number-5">9.2.3.1</span> Contiguous allocation</h5>
<div class="outline-text-5" id="text-9-2-3-1">
<ul class="org-ul">
<li>Disk data blocks contiguous on disk</li>
<li>Need only 1 pointer in device directory entry</li>
<li>Creates disk fragmentation (many un-usable holes)</li>
</ul>
<p>
&rArr; Impractical
</p>
</div>
</div>
<div id="outline-container-org140fe4d" class="outline-5">
<h5 id="org140fe4d"><span class="section-number-5">9.2.3.2</span> Linked List Allocation</h5>
<div class="outline-text-5" id="text-9-2-3-2">
<ul class="org-ul">
<li>Each data block contains pointer to the next</li>
<li>Only 1 pointer in device directory entry (head)</li>
<li>2 If you want to store the tail</li>
<li>Inefficient access (esp. random access)</li>
<li>Pointer space in data block</li>
</ul>
</div>
</div>
<div id="outline-container-orgb047bbe" class="outline-5">
<h5 id="orgb047bbe"><span class="section-number-5">9.2.3.3</span> Indexed Allocation</h5>
<div class="outline-text-5" id="text-9-2-3-3">
<ul class="org-ul">
<li>N pointers in device directory entry</li>
<li>Point to data blocks of the file</li>
<li>Efficient access for small files</li>
<li>What if file size &gt; N*size of data block?</li>
</ul>
</div>
</div>
<div id="outline-container-orgbf244e2" class="outline-5">
<h5 id="orgbf244e2"><span class="section-number-5">9.2.3.4</span> Indexed Allocation with Indirect Blocks</h5>
<div class="outline-text-5" id="text-9-2-3-4">
<ul class="org-ul">
<li>N pointers in device directory entry</li>
<li>First M (&lt;N) point to first M data blocks</li>
<li>Blocks M+1 to N point to <i>indirect blocks</i></li>
</ul>
<p>
<i>Indirect blocks</i> do not contain data, but pointers to subsequent data blocks
(double indirect blocks also possible)
</p>
<ul class="org-ul">
<li>Efficient for small files</li>
<li>Possible to extend to very large files</li>
</ul>
</div>
</div>
<div id="outline-container-org080a9b7" class="outline-5">
<h5 id="org080a9b7"><span class="section-number-5">9.2.3.5</span> Extent-Based Allocation</h5>
<div class="outline-text-5" id="text-9-2-3-5">
<ul class="org-ul">
<li>Device directory entry
<ul class="org-ul">
<li>Contains disk address and length of extent</li>
<li>Instead of just disk address</li>
<li>In other words, point to a sequence of disk blocks</li>
</ul></li>
<li>Good sequential and random access</li>
<li>Can be combined with indirect blocks</li>
<li>Common practice in Linux</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org973502e" class="outline-4">
<h4 id="org973502e"><span class="section-number-4">9.2.4</span> Free space</h4>
<div class="outline-text-4" id="text-9-2-4">
<ul class="org-ul">
<li>Linked list</li>
<li>Bitmap
<ul class="org-ul">
<li>Array[#numsectors]</li>
<li>Free/In-use</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org054b42b" class="outline-3">
<h3 id="org054b42b"><span class="section-number-3">9.3</span> In-Memory Data Structures</h3>
<div class="outline-text-3" id="text-9-3">
</div><div id="outline-container-org5edba75" class="outline-4">
<h4 id="org5edba75"><span class="section-number-4">9.3.1</span> Cache</h4>
<div class="outline-text-4" id="text-9-3-1">
<ul class="org-ul">
<li>Fixed contiguous area of kernel memory</li>
<li>Size = max number of cache blocks x block size</li>
<li>A large chunk of memory of the machine</li>
</ul>
</div>
</div>
<div id="outline-container-org8e14bee" class="outline-4">
<h4 id="org8e14bee"><span class="section-number-4">9.3.2</span> Cache directory</h4>
<div class="outline-text-4" id="text-9-3-2">
<ul class="org-ul">
<li>Usually a hash table</li>
<li>index = hash(disk address)</li>
<li>With an overflow list in case of collision</li>
<li>Usually has a 'dirty' bit</li>
</ul>
</div>
</div>
<div id="outline-container-orge943713" class="outline-4">
<h4 id="orge943713"><span class="section-number-4">9.3.3</span> Active file table</h4>
<div class="outline-text-4" id="text-9-3-3">
<ul class="org-ul">
<li>One array for the entire system (system-wide)</li>
<li>One entry per <i>open file</i></li>
<li>Each entry contains
<ul class="org-ul">
<li>Device directory of file</li>
<li>Additional info (e.g. refcount of number of file opens)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9605279" class="outline-4">
<h4 id="org9605279"><span class="section-number-4">9.3.4</span> Open file tables</h4>
<div class="outline-text-4" id="text-9-3-4">
<ul class="org-ul">
<li>One array per process</li>
<li>One entry per <i>file open</i> of that process</li>
<li>Indexed by file descriptor <i>fd</i></li>
<li>Each entry contains
<ul class="org-ul">
<li>Pointer to entry in active file table</li>
<li>File pointer <i>fp</i></li>
<li>Additional info</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8f26c4f" class="outline-3">
<h3 id="org8f26c4f"><span class="section-number-3">9.4</span> Putting it All Together</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>File systems main methods
<ul class="org-ul">
<li>Create(), Delete()</li>
<li>Open(), Close()</li>
<li>Read(), Write(), Lseek()</li>
<li>Cache flush and replacement</li>
</ul></li>
<li>With some major simplifications
<ul class="org-ul">
<li>No access permission checks</li>
<li>No return value checks</li>
<li>etc&#x2026;</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org2c226ce" class="outline-4">
<h4 id="org2c226ce"><span class="section-number-4">9.4.1</span> uid = Create()</h4>
<div class="outline-text-4" id="text-9-4-1">
<ul class="org-ul">
<li>Find a free uid (refcount = 0)</li>
<li>Set refcount to 1</li>
<li>Fill in additional info</li>
<li>Write back to cache (and to disk)</li>
<li>Device directory is cached in memory</li>
<li>Usually easy to find free uid</li>
</ul>
</div>
</div>
<div id="outline-container-orgde7094d" class="outline-4">
<h4 id="orgde7094d"><span class="section-number-4">9.4.2</span> Delete(uid)</h4>
<div class="outline-text-4" id="text-9-4-2">
<ul class="org-ul">
<li>Find inode</li>
<li>Decrement refcount</li>
<li>If refcount == 0
<ul class="org-ul">
<li>Free all data blocks and indirect blocks</li>
<li>Set entries in free space bitmap to 0</li>
</ul></li>
<li>Write back to cache (and to disk)</li>
</ul>
</div>
</div>
<div id="outline-container-org8905244" class="outline-4">
<h4 id="org8905244"><span class="section-number-4">9.4.3</span> tid = Open(uid)</h4>
<div class="outline-text-4" id="text-9-4-3">
<ul class="org-ul">
<li>Check in Active File Table if uid already open</li>
<li>If so
<ul class="org-ul">
<li>Refcount in Active File Table ++</li>
<li>Allocate entry in Open File Table</li>
<li>Point to entry in Active File Table</li>
<li>Set fp = 0</li>
</ul></li>
<li>If not
<ul class="org-ul">
<li>Find free entry in Active File Table</li>
<li>Read inode and copy in Active File Table entry</li>
<li>Refcount = 0</li>
<li>Allocate entry in Open File Table</li>
<li>Point to entry in Active File Table</li>
<li>Set fp = 0</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb5d622" class="outline-4">
<h4 id="orgcb5d622"><span class="section-number-4">9.4.4</span> Close(tid)</h4>
<div class="outline-text-4" id="text-9-4-4">
<ul class="org-ul">
<li>Find entry in Active File Table</li>
<li>Refcount &#x2013;</li>
<li>If refcount  == 0, remove entry from Active File Table</li>
<li>Remove entry from Open File Table</li>
</ul>
</div>
</div>
<div id="outline-container-orged8ad7f" class="outline-4">
<h4 id="orged8ad7f"><span class="section-number-4">9.4.5</span> Read()</h4>
<div class="outline-text-4" id="text-9-4-5">
<ul class="org-ul">
<li>find fp in open file table and increment</li>
<li>compute block not to be read</li>
<li>Find disk address in inode in Active File Table</li>
<li>Look up in Cache Directory (disk address)</li>
<li>If present, return</li>
<li>If not, find free entry in cache</li>
<li>ReadSector(disk address, free cache block)</li>
</ul>
</div>
</div>
<div id="outline-container-org37d200d" class="outline-4">
<h4 id="org37d200d"><span class="section-number-4">9.4.6</span> Write</h4>
<div class="outline-text-4" id="text-9-4-6">
<ul class="org-ul">
<li>find fp in open file table and increment</li>
<li>compute block not to be written</li>
<li>Find/allocate disk address in Active File Table</li>
<li>Look up in cache directory (disk address)</li>
<li>If present, overwrite and return</li>
<li>If not, find free cache entry and overwrite</li>
</ul>
</div>
</div>
<div id="outline-container-org77bd409" class="outline-4">
<h4 id="org77bd409"><span class="section-number-4">9.4.7</span> Lseek(tid, new<sub>fp</sub>)</h4>
<div class="outline-text-4" id="text-9-4-7">
<ul class="org-ul">
<li>In Open File Table, set fp = new<sub>fp</sub></li>
</ul>
</div>
</div>
<div id="outline-container-org9876103" class="outline-4">
<h4 id="org9876103"><span class="section-number-4">9.4.8</span> Cache Replacement</h4>
<div class="outline-text-4" id="text-9-4-8">
<ul class="org-ul">
<li>Keep LRU list
<ul class="org-ul">
<li>Unlike memory management, here easy to do</li>
<li>Accesses are far fewer (file vs memory access)</li>
</ul></li>
<li>If no more free entries in the cache
<ul class="org-ul">
<li>Replace 'clean' block according to LRU</li>
<li>Replace 'dirty' block according to LRU</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4b71975" class="outline-4">
<h4 id="org4b71975"><span class="section-number-4">9.4.9</span> Cache Flush</h4>
<div class="outline-text-4" id="text-9-4-9">
<ul class="org-ul">
<li>Find "dirty" entries in cache</li>
<li>WriteSector(&#x2026;)</li>
<li>Periodically (30 seconds)</li>
<li>When disk is idle</li>
</ul>
</div>
</div>
<div id="outline-container-org71d6e48" class="outline-4">
<h4 id="org71d6e48"><span class="section-number-4">9.4.10</span> Directories</h4>
<div class="outline-text-4" id="text-9-4-10">
<p>
Directories are stored as files
</p>
</div>
</div>
<div id="outline-container-orgd453844" class="outline-4">
<h4 id="orgd453844"><span class="section-number-4">9.4.11</span> Typical Operation</h4>
<div class="outline-text-4" id="text-9-4-11">
<ul class="org-ul">
<li>fd = Open(string)
<ul class="org-ul">
<li>Directory lookup (disk reads)</li>
<li>Inode lookups (disk reads)</li>
</ul></li>
<li>Read(fd, &#x2026;)
<ul class="org-ul">
<li>Data (disk reads)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org96d660d" class="outline-4">
<h4 id="org96d660d"><span class="section-number-4">9.4.12</span> Disk Behavior</h4>
<div class="outline-text-4" id="text-9-4-12">
<p>
Head moves between
</p>
<ul class="org-ul">
<li>Directories</li>
<li>Inodes</li>
<li>Data</li>
</ul>
</div>
</div>
<div id="outline-container-org93c621c" class="outline-4">
<h4 id="org93c621c"><span class="section-number-4">9.4.13</span> Advanced Disk Layout</h4>
<div class="outline-text-4" id="text-9-4-13">
<ul class="org-ul">
<li>Co-locate related
<ul class="org-ul">
<li>Directories</li>
<li>Inodes</li>
<li>Data</li>
</ul></li>
<li>In same "cylinder group", set of cylinders next to each others</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9b79f1b" class="outline-3">
<h3 id="org9b79f1b"><span class="section-number-3">9.5</span> Loose ends</h3>
<div class="outline-text-3" id="text-9-5">
</div><div id="outline-container-orgf398690" class="outline-4">
<h4 id="orgf398690"><span class="section-number-4">9.5.1</span> File System Check</h4>
<div class="outline-text-4" id="text-9-5-1">
<ul class="org-ul">
<li>Normally, nothing would be necessary</li>
<li>Sometimes things are not normal
<ul class="org-ul">
<li>Disk sector goes bad</li>
<li>File system software has bugs</li>
<li>&#x2026;</li>
</ul></li>
<li>Common to "check the file system (fsck)</li>
</ul>
<p>
Checks:
</p>
<ul class="org-ul">
<li>No sectors are allocated twice</li>
<li>No sectors are allocated and on free list</li>
<li>Reconstruct free list</li>
</ul>
</div>
</div>
<div id="outline-container-orgee23ecd" class="outline-4">
<h4 id="orgee23ecd"><span class="section-number-4">9.5.2</span> Replication</h4>
<div class="outline-text-4" id="text-9-5-2">
<ul class="org-ul">
<li>Some key sectors are replicated
<ul class="org-ul">
<li>Boot blocks</li>
<li>Sometimes also device directory</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org499abaf" class="outline-4">
<h4 id="org499abaf"><span class="section-number-4">9.5.3</span> Disk Fragmentation</h4>
<div class="outline-text-4" id="text-9-5-3">
<ul class="org-ul">
<li>Free space consists of
<ul class="org-ul">
<li>Small "holes" (of 1 or 2 sectors)</li>
<li>Spread all over the disk</li>
</ul></li>
<li>Happens even with good disk allocation</li>
<li>No longer possible to do good disk allocation</li>
</ul>
</div>
<div id="outline-container-org3ac02e3" class="outline-5">
<h5 id="org3ac02e3"><span class="section-number-5">9.5.3.1</span> Disk Defragmentation Utility</h5>
<div class="outline-text-5" id="text-9-5-3-1">
<ul class="org-ul">
<li>Takes the file system offline</li>
<li>Moves files into contiguous locations</li>
<li>Better performance</li>
<li>More room for good disk allocation</li>
<li>Can be done online, but tricky</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org96f2406" class="outline-3">
<h3 id="org96f2406"><span class="section-number-3">9.6</span> Memory Mapping</h3>
<div class="outline-text-3" id="text-9-6">
<ul class="org-ul">
<li>mmap() &rarr; map the contents of a file in memory</li>
<li>munmap() &rarr; remove the mapping</li>
</ul>
<p>
mmap region = between heap and stack in virtual address space, interesting to
have 64bit address space, since the mmap region is now huge.
</p>
</div>
<div id="outline-container-org6fc4c11" class="outline-4">
<h4 id="org6fc4c11"><span class="section-number-4">9.6.1</span> Access to mmap()-ed files</h4>
<div class="outline-text-4" id="text-9-6-1">
<ul class="org-ul">
<li>Access to memory region mmap()-ed</li>
<li>Causes page fault</li>
<li>Causes page/block of file to be brought in</li>
</ul>
</div>
</div>
<div id="outline-container-orgced7a33" class="outline-4">
<h4 id="orgced7a33"><span class="section-number-4">9.6.2</span> Implementation</h4>
<div class="outline-text-4" id="text-9-6-2">
<ul class="org-ul">
<li>On mmap()
<ul class="org-ul">
<li>Allocate page table entries</li>
<li>Set valid bit to "invalid"</li>
</ul></li>
<li>On access
<ul class="org-ul">
<li>Page fault</li>
<li>File = backing store for mapped region of memory</li>
<li>Just like in demand paging</li>
<li>Except paged from mapped file</li>
</ul></li>
<li>After page fault handling, set valid bit to true</li>
</ul>
<p>
Getting data to disk from mmap, through normal page replacement or through an
explicit call to msync()
</p>
</div>
</div>
<div id="outline-container-orgd422885" class="outline-4">
<h4 id="orgd422885"><span class="section-number-4">9.6.3</span> What is mmap() good for?</h4>
<div class="outline-text-4" id="text-9-6-3">
</div><div id="outline-container-orgff61faa" class="outline-5">
<h5 id="orgff61faa"><span class="section-number-5">9.6.3.1</span> Random access to large file</h5>
<div class="outline-text-5" id="text-9-6-3-1">
<ul class="org-ul">
<li>addr = mmap()</li>
<li>Use memory addresses in [addr, addr+len-1]</li>
<li>Easy to write</li>
<li>Only bring in memory what you read</li>
<li>Easy reuse</li>
</ul>
</div>
</div>
<div id="outline-container-org08215d1" class="outline-5">
<h5 id="org08215d1"><span class="section-number-5">9.6.3.2</span> Random access with Read() interface</h5>
<div class="outline-text-5" id="text-9-6-3-2">
<ul class="org-ul">
<li>Open</li>
<li>Read entire file into memory buffer</li>
<li>Then use memory address in buffer</li>
</ul>
<p>
Advantages with mmap():
</p>
<ul class="org-ul">
<li>Only accessed portions brought in memory</li>
<li>Huge advantage for large files or sparsely accessed files.</li>
</ul>
</div>
</div>
<div id="outline-container-org83da8c9" class="outline-5">
<h5 id="org83da8c9"><span class="section-number-5">9.6.3.3</span> Random access with LSeek()</h5>
<div class="outline-text-5" id="text-9-6-3-3">
<ul class="org-ul">
<li>Open</li>
<li>LSeek</li>
<li>Read into Buffer</li>
<li>LSeek</li>
<li>Read into Buffer</li>
</ul>
<p>
Advantages with mmap():
</p>
<ul class="org-ul">
<li>Much easier programming model
<ul class="org-ul">
<li>Follow pointer in memory</li>
<li>As opposed to (Lseek,Read) every time</li>
</ul></li>
<li>Easier if reuse
<ul class="org-ul">
<li>VM system keeps page for you</li>
<li>Otherwise, have to do your own replacement</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4243d34" class="outline-4">
<h4 id="org4243d34"><span class="section-number-4">9.6.4</span> Issues with mmap()</h4>
<div class="outline-text-4" id="text-9-6-4">
<ul class="org-ul">
<li>Alignment on page boundary</li>
<li>not easy to extend a file</li>
<li>For small files &rarr; Read() more efficient than mmap() + page fault</li>
</ul>
</div>
</div>
<div id="outline-container-org1eafa28" class="outline-4">
<h4 id="org1eafa28"><span class="section-number-4">9.6.5</span> Using mmap() for memory sharing</h4>
<div class="outline-text-4" id="text-9-6-5">
<ul class="org-ul">
<li>Sharing memory between processes</li>
<li>A form of interprocess communication</li>
<li>Use shared and anonymous map flags</li>
</ul>
</div>
<div id="outline-container-org2404e2d" class="outline-5">
<h5 id="org2404e2d"><span class="section-number-5">9.6.5.1</span> Implementation</h5>
<div class="outline-text-5" id="text-9-6-5-1">
<ul class="org-ul">
<li>File system has buffer cache, file data on disk, recently used data in memory</li>
<li>Memory management has page replacement, data in memory, not recently used data
on disk</li>
<li>Same thing, but from an opposite angle</li>
</ul>
</div>
</div>
<div id="outline-container-org565e3e7" class="outline-5">
<h5 id="org565e3e7"><span class="section-number-5">9.6.5.2</span> Integrated Buffer Cache</h5>
<div class="outline-text-5" id="text-9-6-5-2">
<ul class="org-ul">
<li>One region of memory</li>
<li>Used both as
<ul class="org-ul">
<li>File system buffer cache</li>
<li>Demand paged in-memory data</li>
</ul></li>
<li>Advantage:
<ul class="org-ul">
<li>One piece of code instead of two</li>
<li>Avoids "double caching"</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f43781" class="outline-2">
<h2 id="org1f43781"><span class="section-number-2">10</span> Week 10</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-org5ed65ba" class="outline-3">
<h3 id="org5ed65ba"><span class="section-number-3">10.1</span> Atomicity</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>Atomicity = "all or nothings"</li>
<li>In a file system:
<ul class="org-ul">
<li>All updates are on disk</li>
<li>No updates are on disk</li>
<li>Nothing in between</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org41bd3ba" class="outline-4">
<h4 id="org41bd3ba"><span class="section-number-4">10.1.1</span> Assumption</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
A single disk write is atomic
</p>
</div>
</div>
<div id="outline-container-org572f75c" class="outline-4">
<h4 id="org572f75c"><span class="section-number-4">10.1.2</span> Implementation</h4>
<div class="outline-text-4" id="text-10-1-2">
<ul class="org-ul">
<li>Make sure we have an old copy on disk</li>
<li>Make sure we have a new copy on disk</li>
<li>Switch atomically between the two</li>
</ul>
</div>
</div>
<div id="outline-container-org5ebed84" class="outline-4">
<h4 id="org5ebed84"><span class="section-number-4">10.1.3</span> Atomic Switch with DDE</h4>
<div class="outline-text-4" id="text-10-1-3">
<ul class="org-ul">
<li>We do a WriteSector()</li>
<li>What to write with it?
<ul class="org-ul">
<li>Device directory entry!</li>
<li>Because it is smaller than sector</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb1535b1" class="outline-5">
<h5 id="orgb1535b1"><span class="section-number-5">10.1.3.1</span> How it works with Write-Through</h5>
<div class="outline-text-5" id="text-10-1-3-1">
<ul class="org-ul">
<li>open(): read dde into aft</li>
<li>write()s
<ul class="org-ul">
<li>allocate <b>new</b> blocks on disk for data</li>
<li>fill in address of new blocks in <i>incore</i> dde</li>
<li>write to cache and disk</li>
</ul></li>
<li>close() write <i>incore</i> dde to <i>disk</i> dde</li>
</ul>
</div>
</div>
<div id="outline-container-orgf6a52bc" class="outline-5">
<h5 id="orgf6a52bc"><span class="section-number-5">10.1.3.2</span> How it works with Write-Behind</h5>
<div class="outline-text-5" id="text-10-1-3-2">
<ul class="org-ul">
<li>open(): read dde into aft</li>
<li>write()s
<ul class="org-ul">
<li>allocate <b>new</b> blocks for new data</li>
<li>Write disk addresses to <i>incore</i> dde</li>
<li>write to cache</li>
</ul></li>
<li>close()
<ul class="org-ul">
<li>Write <b>all</b> cached block to new disk blocks</li>
<li>write <i>incore</i> dde to <i>disk</i> dde</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5137aa6" class="outline-5">
<h5 id="org5137aa6"><span class="section-number-5">10.1.3.3</span> What happens to old blocks?</h5>
<div class="outline-text-5" id="text-10-1-3-3">
<ul class="org-ul">
<li>De-allocate them</li>
<li>If crash before de-allocate, file system check</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb07b753" class="outline-4">
<h4 id="orgb07b753"><span class="section-number-4">10.1.4</span> Atomic Switch with Intentions Log</h4>
<div class="outline-text-4" id="text-10-1-4">
<ul class="org-ul">
<li>Reserve an area of disk for (intentions) log</li>
<li>During normal operations
<ul class="org-ul">
<li>On write
<ul class="org-ul">
<li>Write to cache</li>
<li>Write to log</li>
<li>Make in-memory inode point to update in log</li>
</ul></li>
<li>On Close
<ul class="org-ul">
<li>Write old and new inode to log in one disk write</li>
<li>Copy updates from log to original disk locations</li>
<li>When all updates done, overwrite inode with new value</li>
<li>Remove updates and old and new inode from the log</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org30649c0" class="outline-5">
<h5 id="org30649c0"><span class="section-number-5">10.1.4.1</span> Crash Recovery</h5>
<div class="outline-text-5" id="text-10-1-4-1">
<ul class="org-ul">
<li>Search forward through log</li>
<li>For each new inode found
<ul class="org-ul">
<li>Find and copy updates to their original location</li>
<li>If when all updates are done, write new inode</li>
<li>Remove updates and old and new inode from log</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org22c5cf9" class="outline-5">
<h5 id="org22c5cf9"><span class="section-number-5">10.1.4.2</span> Invariant</h5>
<div class="outline-text-5" id="text-10-1-4-2">
<ul class="org-ul">
<li>If new inode in the log and crash: new copy</li>
<li>If new inode not in the log and crash: old copy</li>
<li>Even if you crash during crash recovery, you may copy and update multiple
times</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8d4b628" class="outline-4">
<h4 id="org8d4b628"><span class="section-number-4">10.1.5</span> Comparisons</h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
Count the number of (Random) disk I/Os:
</p>
<ul class="org-ul">
<li>DDE one write per write()/close()</li>
<li>Log: two write per write()(log,data), one per close()</li>
</ul>
<p>
However, log works better
</p>
<ul class="org-ul">
<li>Write()'s to log are sequential (no seeks)</li>
<li>Data blocks stay in place</li>
<li>Good disk allocation stays!</li>
<li>Write from cache of log to data - when disk is idle or cache replacement</li>
</ul>
<p>
DDE works less well:
</p>
<ul class="org-ul">
<li>Disk allocation gets messed up</li>
<li>Fragmentation</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org40f6648" class="outline-3">
<h3 id="org40f6648"><span class="section-number-3">10.2</span> Log-Structured File System (LFS)</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Alternative way of structuring file system</li>
<li>Takes idea of log writes to the extreme</li>
</ul>
</div>
<div id="outline-container-org9a209b6" class="outline-4">
<h4 id="org9a209b6"><span class="section-number-4">10.2.1</span> Rationale</h4>
<div class="outline-text-4" id="text-10-2-1">
<ul class="org-ul">
<li>Large memories &rarr; large buffer caches</li>
<li>Most reads served from cache</li>
<li>Most disk traffic is write traffic</li>
<li>How to optimize disk I/O? By optimizing writes</li>
<li>How to optimize disk writes? By writing sequentially to disk</li>
</ul>
</div>
</div>
<div id="outline-container-orgf10bc2f" class="outline-4">
<h4 id="orgf10bc2f"><span class="section-number-4">10.2.2</span> Key idea</h4>
<div class="outline-text-4" id="text-10-2-2">
<ul class="org-ul">
<li>Log = append-only data structure (on disk)</li>
<li><i>All</i> writes are to a log, including data and inode modifications</li>
</ul>
</div>
</div>
<div id="outline-container-org7c0d4d7" class="outline-4">
<h4 id="org7c0d4d7"><span class="section-number-4">10.2.3</span> Write() in LFS</h4>
<div class="outline-text-4" id="text-10-2-3">
<ul class="org-ul">
<li>Write first go into cache (write-behind), both inodes and data</li>
<li>Writes also go into (in-memory) buffer</li>
<li>When buffer full, append to log</li>
<li>Called <i>segment</i> of log</li>
<li>No seeks on writes!</li>
</ul>
</div>
</div>
<div id="outline-container-orgb7cfa28" class="outline-4">
<h4 id="orgb7cfa28"><span class="section-number-4">10.2.4</span> Inode Map</h4>
<div class="outline-text-4" id="text-10-2-4">
<p>
Allows to read
</p>
<ul class="org-ul">
<li>(In-memory) table of inode disk addresses, maps <i>uid</i> to disk address of last
inode for that <i>uid</i></li>
<li>Updated every time inode is written to disk</li>
</ul>
</div>
<div id="outline-container-orga78202f" class="outline-5">
<h5 id="orga78202f"><span class="section-number-5">10.2.4.1</span> Usage</h5>
<div class="outline-text-5" id="text-10-2-4-1">
<ul class="org-ul">
<li>Open():
<ul class="org-ul">
<li>Get inode address from inode map</li>
<li>Read inode from disk into Active File Table</li>
</ul></li>
<li>Read(): as before
<ul class="org-ul">
<li>Get from cache</li>
<li>Get from disk address in inode</li>
</ul></li>
<li>Reading seems more complicated because of indirection through inode map</li>
<li>Performance is determined by disk writes, so little difference</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org614fd16" class="outline-4">
<h4 id="org614fd16"><span class="section-number-4">10.2.5</span> Checkpoint</h4>
<div class="outline-text-4" id="text-10-2-5">
<p>
Checkpoint inode map:
</p>
<ul class="org-ul">
<li>Write copy of inode map to fixed location on disk</li>
<li>Put marker in the log</li>
</ul>
</div>
<div id="outline-container-orga4e1061" class="outline-5">
<h5 id="orga4e1061"><span class="section-number-5">10.2.5.1</span> Crash</h5>
<div class="outline-text-5" id="text-10-2-5-1">
<ul class="org-ul">
<li>Start from inode map in checkpoint, contains addresses of all inodes written
<i>before</i> last checkpoint</li>
<li>How to find inodes that were in in-memory inode map before crash, but not
written in the checkpoint?</li>
</ul>
</div>
</div>
<div id="outline-container-org65e2eab" class="outline-5">
<h5 id="org65e2eab"><span class="section-number-5">10.2.5.2</span> Roll Forward</h5>
<div class="outline-text-5" id="text-10-2-5-2">
<ul class="org-ul">
<li>Checkpoint put marker in log</li>
<li>From marker forward
<ul class="org-ul">
<li>Scan for inodes in the log</li>
<li>Add their addresses to inode map</li>
</ul></li>
<li>Result: all inode addresses in inode map before crash are in inode map
afterwards</li>
</ul>
</div>
</div>
<div id="outline-container-org5d466a9" class="outline-5">
<h5 id="org5d466a9"><span class="section-number-5">10.2.5.3</span> Time interval</h5>
<div class="outline-text-5" id="text-10-2-5-3">
<ul class="org-ul">
<li>Too short: lots of disk I/O to write checkpoints</li>
<li>Too long: long recovery time (forward scan)</li>
<li>Compromise:
<ul class="org-ul">
<li>Crashes are rare</li>
<li>So is recovery</li>
<li>Can tolerate longer recovery time</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org53f9b7c" class="outline-4">
<h4 id="org53f9b7c"><span class="section-number-4">10.2.6</span> Disk if full</h4>
<div class="outline-text-4" id="text-10-2-6">
<ul class="org-ul">
<li>No sector is ever overwritten, always written to end of log</li>
<li>No sector is every put on free list</li>
<li>So disk will get fully (quickly)</li>
<li>Need to "clean" the disk</li>
</ul>
</div>
</div>
<div id="outline-container-orgf043904" class="outline-4">
<h4 id="orgf043904"><span class="section-number-4">10.2.7</span> Disk Cleaning</h4>
<div class="outline-text-4" id="text-10-2-7">
<ul class="org-ul">
<li>Reclaim "old" data</li>
<li>"old" here means
<ul class="org-ul">
<li>Logically overwritten, later write to (uid, blockno)</li>
<li>But not physically overwritten, older version of (uid, blockno) somewhere in
the log</li>
</ul></li>
<li>Done one segment at a time
<ul class="org-ul">
<li>Determine which blocks are new</li>
<li>Write them into buffer</li>
<li>If buffer is full, write new segment</li>
<li>Cleaned segment is marked free</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org47f8b6e" class="outline-4">
<h4 id="org47f8b6e"><span class="section-number-4">10.2.8</span> Log</h4>
<div class="outline-text-4" id="text-10-2-8">
<ul class="org-ul">
<li>Log is more complicated than simple linear log</li>
<li>Log = sequence of segments, some in use, some free</li>
</ul>
</div>
<div id="outline-container-orgbc290e5" class="outline-5">
<h5 id="orgbc290e5"><span class="section-number-5">10.2.8.1</span> Write()</h5>
<div class="outline-text-5" id="text-10-2-8-1">
<ul class="org-ul">
<li>Rather than append to log, write to free segment in log</li>
<li>Segments are larges (MBs), still get benefits from sequential access</li>
</ul>
</div>
</div>
<div id="outline-container-org76dc484" class="outline-5">
<h5 id="org76dc484"><span class="section-number-5">10.2.8.2</span> Block age</h5>
<div class="outline-text-5" id="text-10-2-8-2">
<p>
Change write a bit, instead of just writing data, we write data + uid + blockno
</p>

<p>
To determine if a block is old:
</p>
<ul class="org-ul">
<li>For a data block</li>
<li>Take its disk address</li>
<li>Take its uid and block no</li>
<li>Look in inode map and then in inode</li>
<li>If inode has different disk address &rarr; old</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga063eae" class="outline-4">
<h4 id="orga063eae"><span class="section-number-4">10.2.9</span> Summary</h4>
<div class="outline-text-4" id="text-10-2-9">
<ul class="org-ul">
<li>All writes go to log, including data and inode, but <b>excluding</b> checkpoints</li>
<li>Checkpoint region at fixed disk location on disk, log uses the remainder,
segments are large contiguous regions on disk</li>
<li>In the segment
<ul class="org-ul">
<li>data = modified user data sector (includes uid and block no)</li>
<li>Inode = modified inode sector</li>
</ul></li>
<li>Cache: regular write-behind buffer cache</li>
<li>Segment buffer: segment being written</li>
<li>Inode map:
<ul class="org-ul">
<li>Array</li>
<li>Indexed by <i>uid</i></li>
<li>Points to last-written inode for <i>uid</i></li>
</ul></li>
<li>In memory, usual (active file table, open file tables)</li>
</ul>
</div>
<div id="outline-container-org6fdd87a" class="outline-5">
<h5 id="org6fdd87a"><span class="section-number-5">10.2.9.1</span> Write()</h5>
<div class="outline-text-5" id="text-10-2-9-1">
<ul class="org-ul">
<li>Write go into (write-behind) cache, both inodes and data sectors</li>
<li>Write go into (in-memory) segment buffer, both again</li>
<li>When segment buffer is full, write to free segment in disk log</li>
<li>(Almost) no seeks on writes!</li>
<li>If inode is written to log</li>
<li>inode<sub>map</sub>[uid] = disk address of inode</li>
</ul>
</div>
</div>
<div id="outline-container-orgb84f2fa" class="outline-5">
<h5 id="orgb84f2fa"><span class="section-number-5">10.2.9.2</span> Open()</h5>
<div class="outline-text-5" id="text-10-2-9-2">
<ul class="org-ul">
<li>Get inode address from inode map</li>
<li>Read inode from disk into Active File Table</li>
</ul>
</div>
</div>
<div id="outline-container-orgf34daf3" class="outline-5">
<h5 id="orgf34daf3"><span class="section-number-5">10.2.9.3</span> Read()</h5>
<div class="outline-text-5" id="text-10-2-9-3">
<ul class="org-ul">
<li>Get from cache</li>
<li>If not in cache, get from disk using disk address in inode</li>
</ul>
<p>
As before
</p>
</div>
</div>
<div id="outline-container-orgb1d613d" class="outline-5">
<h5 id="orgb1d613d"><span class="section-number-5">10.2.9.4</span> Conclusion</h5>
<div class="outline-text-5" id="text-10-2-9-4">
<ul class="org-ul">
<li>Reads mostly from cache</li>
<li>Writes to disk heavily optimized: few seeks</li>
<li>Reads from disk: bit more expensive, but few</li>
<li>Cost of cleaning</li>
<li>Not become mainstream</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org997b842" class="outline-2">
<h2 id="org997b842"><span class="section-number-2">11</span> Week 11</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-orgb6138f2" class="outline-3">
<h3 id="orgb6138f2"><span class="section-number-3">11.1</span> Disk issues</h3>
<div class="outline-text-3" id="text-11-1">
<ul class="org-ul">
<li>Bandwidth:
<ul class="org-ul">
<li>Servers</li>
<li>'Big data' computations</li>
</ul></li>
<li>Response time:
<ul class="org-ul">
<li>Desktops and laptops</li>
<li>Transaction systems</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2e9c9af" class="outline-3">
<h3 id="org2e9c9af"><span class="section-number-3">11.2</span> RAID</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Redundant Array of Independent Disks
</p>

<p>
Essential idea:
</p>
<ul class="org-ul">
<li>Optimize I/O bandwidth through parallel I/O</li>
<li>Parallel I/O = I/O to multiple disks at once</li>
</ul>
</div>
<div id="outline-container-orgb9e163a" class="outline-4">
<h4 id="orgb9e163a"><span class="section-number-4">11.2.1</span> Striping</h4>
<div class="outline-text-4" id="text-11-2-1">
<ul class="org-ul">
<li>Rather than put file on one disk</li>
<li>Stripe it across a number of disks
<ul class="org-ul">
<li>File = stripe0 stripe1 stripe2</li>
<li>stripe0 on disk0</li>
<li>stripe1 on disk1</li>
<li>&#x2026;</li>
</ul></li>
<li>Read and write in parallel</li>
</ul>
</div>
</div>
<div id="outline-container-orgae282b6" class="outline-4">
<h4 id="orgae282b6"><span class="section-number-4">11.2.2</span> Potential gain</h4>
<div class="outline-text-4" id="text-11-2-2">
<ul class="org-ul">
<li>Since disk is the bottleneck</li>
<li>Bandwidth of RAID with <i>n</i> disks = <i>n</i> * bandwidth of individual disks</li>
<li>At some points other factors, bandwidth of I/O bus, controller, etc.</li>
<li>But still, bandwidth of RAID &gt;&gt; bandwidth disk</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0ef865b" class="outline-3">
<h3 id="org0ef865b"><span class="section-number-3">11.3</span> RAID format</h3>
<div class="outline-text-3" id="text-11-3">
<ul class="org-ul">
<li>Disk now cheap and small</li>
<li>Many can go into a RAID box</li>
<li>To OS: RAID box looks like disk</li>
<li>Also possible: RAID in software</li>
</ul>
</div>
<div id="outline-container-org30400ac" class="outline-4">
<h4 id="org30400ac"><span class="section-number-4">11.3.1</span> Redudancy</h4>
<div class="outline-text-4" id="text-11-3-1">
<p>
Problem with naïve RAID
</p>
<ul class="org-ul">
<li>One disk fails &rarr; all data unavailable</li>
<li>MTBF (RAID) = MTBF (disk) / n</li>
<li>MTBF (disk) ~ 5 years</li>
<li>MTBF (RAID with 10 disks) ~ 0.5 year</li>
<li>Not acceptable</li>
</ul>
<p>
Solution: store redundant data on different disks, one disk fails, data still
available
</p>
</div>
</div>

<div id="outline-container-org5573f0f" class="outline-4">
<h4 id="org5573f0f"><span class="section-number-4">11.3.2</span> RAID-0</h4>
<div class="outline-text-4" id="text-11-3-2">
<ul class="org-ul">
<li>Non-redundant disk array</li>
<li>Best possible read and write bandwidth</li>
<li>Failure results in data loss</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">D0</th>
<th scope="col" class="org-left">D1</th>
<th scope="col" class="org-left">D2</th>
<th scope="col" class="org-left">D3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">s0</td>
<td class="org-left">s1</td>
<td class="org-left">s2</td>
<td class="org-left">s3</td>
</tr>

<tr>
<td class="org-left">s4</td>
<td class="org-left">s5</td>
<td class="org-left">s6</td>
<td class="org-left">s7</td>
</tr>

<tr>
<td class="org-left">s8</td>
<td class="org-left">s9</td>
<td class="org-left">s10</td>
<td class="org-left">s11</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orged4d03f" class="outline-4">
<h4 id="orged4d03f"><span class="section-number-4">11.3.3</span> RAID-1</h4>
<div class="outline-text-4" id="text-11-3-3">
<ul class="org-ul">
<li>Mirrored disks</li>
<li>Write: to data and to mirror disk</li>
<li>Read: from either data or mirror</li>
<li>After crash: from surviving disk</li>
</ul>
<p>
Halves the storage capacity with the same number of disk, however survives disk
failure of data or mirror
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">D0</th>
<th scope="col" class="org-left">D1</th>
<th scope="col" class="org-left">D2</th>
<th scope="col" class="org-left">D3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">s0</td>
<td class="org-left">s1</td>
<td class="org-left">s0</td>
<td class="org-left">s1</td>
</tr>

<tr>
<td class="org-left">s2</td>
<td class="org-left">s3</td>
<td class="org-left">s2</td>
<td class="org-left">s3</td>
</tr>

<tr>
<td class="org-left">s4</td>
<td class="org-left">s5</td>
<td class="org-left">s3</td>
<td class="org-left">s5</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org748d362" class="outline-4">
<h4 id="org748d362"><span class="section-number-4">11.3.4</span> RAID-4</h4>
<div class="outline-text-4" id="text-11-3-4">
<p>
N data disks + 1 parity disk
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">D0</th>
<th scope="col" class="org-left">D1</th>
<th scope="col" class="org-left">D2</th>
<th scope="col" class="org-left">D3</th>
<th scope="col" class="org-left">D4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">s0</td>
<td class="org-left">s1</td>
<td class="org-left">s2</td>
<td class="org-left">s3</td>
<td class="org-left">p0-3</td>
</tr>

<tr>
<td class="org-left">s4</td>
<td class="org-left">s5</td>
<td class="org-left">s6</td>
<td class="org-left">s7</td>
<td class="org-left">p4-7</td>
</tr>

<tr>
<td class="org-left">s8</td>
<td class="org-left">s9</td>
<td class="org-left">s10</td>
<td class="org-left">s11</td>
<td class="org-left">p8-11</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org88595ea" class="outline-5">
<h5 id="org88595ea"><span class="section-number-5">11.3.4.1</span> Parity</h5>
<div class="outline-text-5" id="text-11-3-4-1">
<ul class="org-ul">
<li>A simple form of error detection and repair</li>
<li>Not specific to RAID, also used in communications</li>
</ul>


<ul class="org-ul">
<li>4 bits: x<sub>0</sub>, x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>
<ul class="org-ul">
<li>= 0101</li>
</ul></li>
<li>Parity p = x<sub>0</sub> XOR x<sub>1</sub> XOR x<sub>2</sub> XOR x<sub>3</sub> 
<ul class="org-ul">
<li>= 0</li>
</ul></li>
<li>if you lose one, say x<sub>2</sub>, reconstruct as x<sub>2</sub> = x<sub>0</sub> XOR x<sub>1</sub> XOR x<sub>3</sub> XOR p
<ul class="org-ul">
<li>0 XOR 1 XOR 1 XOR 0 = 0</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0e3c014" class="outline-5">
<h5 id="org0e3c014"><span class="section-number-5">11.3.4.2</span> RAID parity block</h5>
<div class="outline-text-5" id="text-11-3-4-2">
<ul class="org-ul">
<li>Same idea at the disk block level</li>
<li>Block on parity disk = XOR of bits of data blocks at same position</li>
</ul>
</div>
</div>
<div id="outline-container-org5b743a5" class="outline-5">
<h5 id="org5b743a5"><span class="section-number-5">11.3.4.3</span> Usage</h5>
<div class="outline-text-5" id="text-11-3-4-3">
<ul class="org-ul">
<li>Read: read data disks</li>
<li>Write: write data disks and parity disk</li>
<li>Crash: recover from data and parity disk</li>
</ul>
</div>
</div>
<div id="outline-container-org42d6ca5" class="outline-5">
<h5 id="org42d6ca5"><span class="section-number-5">11.3.4.4</span> Issue</h5>
<div class="outline-text-5" id="text-11-3-4-4">
<p>
Every write has to access parity disk, become bottleneck for write-heavy workload
</p>
</div>
</div>
</div>
<div id="outline-container-org91e26d5" class="outline-4">
<h4 id="org91e26d5"><span class="section-number-4">11.3.5</span> RAID-5</h4>
<div class="outline-text-4" id="text-11-3-5">
<ul class="org-ul">
<li>Block interleaved distributed parity</li>
<li>As RAID-4, but parity distributed over all disks</li>
<li>Balance parity write load over disks</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">D0</th>
<th scope="col" class="org-left">D1</th>
<th scope="col" class="org-left">D2</th>
<th scope="col" class="org-left">D3</th>
<th scope="col" class="org-left">D4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">s0</td>
<td class="org-left">s1</td>
<td class="org-left">s2</td>
<td class="org-left">s3</td>
<td class="org-left">p0-3</td>
</tr>

<tr>
<td class="org-left">s4</td>
<td class="org-left">s5</td>
<td class="org-left">s6</td>
<td class="org-left">p4-7</td>
<td class="org-left">s7</td>
</tr>

<tr>
<td class="org-left">s8</td>
<td class="org-left">s9</td>
<td class="org-left">p8-11</td>
<td class="org-left">s10</td>
<td class="org-left">s11</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org1bf4482" class="outline-3">
<h3 id="org1bf4482"><span class="section-number-3">11.4</span> SSD</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li>Is not a disk!</li>
<li>Purely electronic (NAND Flash)</li>
<li>No moving parts</li>
<li>Made to look like a disk (to both hardware and software)</li>
</ul>
</div>
<div id="outline-container-org4f8a402" class="outline-4">
<h4 id="org4f8a402"><span class="section-number-4">11.4.1</span> NAND basics</h4>
<div class="outline-text-4" id="text-11-4-1">
<ul class="org-ul">
<li>Basic unit: page - 4K</li>
<li>Block = set of pages - e.g., 64 pages</li>
</ul>
</div>
</div>
<div id="outline-container-org92f4b1d" class="outline-4">
<h4 id="org92f4b1d"><span class="section-number-4">11.4.2</span> NAND Flash Operations</h4>
<div class="outline-text-4" id="text-11-4-2">
<ul class="org-ul">
<li>Read(page)</li>
<li>Write(page), cannot rewrite a page</li>
<li>Erase(block)
<ul class="org-ul">
<li>Necessary before page in block can be rewritten</li>
<li>Limited number of erase cycles (100,000s)</li>
</ul></li>
<li>Since block must be completely erased before any single page in a block is
written, pages are typically written sequentially in a block</li>
</ul>
</div>
</div>
<div id="outline-container-org7244692" class="outline-4">
<h4 id="org7244692"><span class="section-number-4">11.4.3</span> SSD interface</h4>
<div class="outline-text-4" id="text-11-4-3">
<ul class="org-ul">
<li>Very much like a disk</li>
<li>ReadSector( logical<sub>sector</sub><sub>no</sub>, buffer)</li>
<li>WriteSector(logical<sub>sector</sub><sub>no</sub>, buffer)</li>
<li>Logical sector map maintained on device</li>
</ul>
</div>
</div>
<div id="outline-container-orgbdf3355" class="outline-4">
<h4 id="orgbdf3355"><span class="section-number-4">11.4.4</span> SSD Characteristics</h4>
<div class="outline-text-4" id="text-11-4-4">
<ul class="org-ul">
<li>Bandwidth higher than disk</li>
<li>Latency: much lower than disk, 100 microseconds for read, 300 for write</li>
<li>Several outstanding commands</li>
</ul>
</div>
</div>
<div id="outline-container-org873763c" class="outline-4">
<h4 id="org873763c"><span class="section-number-4">11.4.5</span> Building a File System for SSD</h4>
<div class="outline-text-4" id="text-11-4-5">
<ul class="org-ul">
<li>Need to write sequentially</li>
<li>Cannot overwrite (need to erase before)</li>
</ul>
<p>
Looks like LFS
</p>
<ul class="org-ul">
<li>Clean block before erasing</li>
<li>Move live data to new block</li>
<li>Erase block</li>
</ul>
</div>
</div>
<div id="outline-container-org834ee55" class="outline-4">
<h4 id="org834ee55"><span class="section-number-4">11.4.6</span> TRIM command</h4>
<div class="outline-text-4" id="text-11-4-6">
<ul class="org-ul">
<li>TRIM(range of logical<sub>sector</sub><sub>no</sub>'s)</li>
<li>Indicate to device no longer in use</li>
<li>No need to do cleaning, just erase</li>
</ul>
<p>
Need to try to even out the number of erase cycles
</p>
</div>
</div>
<div id="outline-container-orgdafcf3c" class="outline-4">
<h4 id="orgdafcf3c"><span class="section-number-4">11.4.7</span> Utility</h4>
<div class="outline-text-4" id="text-11-4-7">
<ul class="org-ul">
<li>Good for
<ul class="org-ul">
<li>Response time</li>
<li>Bandwidth</li>
<li>Robustness</li>
</ul></li>
<li>Bad for
<ul class="org-ul">
<li>Price</li>
<li>Capacity</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd9995ac" class="outline-2">
<h2 id="orgd9995ac"><span class="section-number-2">12</span> Week 12</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-orgc83131e" class="outline-3">
<h3 id="orgc83131e"><span class="section-number-3">12.1</span> Virtual machine</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Virtual Machine Monitor (VMM) or hypervisor</li>
<li>Machine running on a machine</li>
<li>Usually, many machines running on a machine</li>
</ul>
</div>
<div id="outline-container-org47a188c" class="outline-4">
<h4 id="org47a188c"><span class="section-number-4">12.1.1</span> Differences from programs running on OS</h4>
<div class="outline-text-4" id="text-12-1-1">
<ul class="org-ul">
<li>Both provide resource management
<ul class="org-ul">
<li>Sharing resources between applications in OS</li>
<li>Sharing resources between VMs in VMM</li>
</ul></li>
<li>Differs on abstraction
<ul class="org-ul">
<li>OS provides abstractions (processes, address spaces, file systems,&#x2026;)</li>
<li>VMM does not provide abstraction, provides an identical copy of the machine</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8cca2cc" class="outline-4">
<h4 id="org8cca2cc"><span class="section-number-4">12.1.2</span> VMM</h4>
<div class="outline-text-4" id="text-12-1-2">
<ul class="org-ul">
<li>Resources manager for VMs</li>
<li>Provides
<ul class="org-ul">
<li>Creation, destruction and scheduling of VMs</li>
<li>Memory management for VMs</li>
<li>Disk management for VMs</li>
<li>I/O management for VMs</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgff95931" class="outline-4">
<h4 id="orgff95931"><span class="section-number-4">12.1.3</span> Terminology</h4>
<div class="outline-text-4" id="text-12-1-3">
<ul class="org-ul">
<li>Virtual Machine (VM) = efficient isolated duplicate of real machine</li>
<li>Virtual Machine Monitor (VMM) or hypervisor = provider of VMs
<ul class="org-ul">
<li>Is in control of the hardware</li>
<li>Uses hardware to efficiently provides VMs</li>
</ul></li>
<li>Guest operating system = OS that runs in a VM</li>
<li>Native mode = application or OS running on real hardware</li>
<li>Virtualized mode = application or OS running on real hardware</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6e59168" class="outline-3">
<h3 id="org6e59168"><span class="section-number-3">12.2</span> VMM implementation</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>Kernel user boundary between VMM and VMs</li>
<li>Problem: guest OSes operate in user mode, but written to operate in kernel
mode</li>
</ul>
</div>
<div id="outline-container-org6eedc9c" class="outline-4">
<h4 id="org6eedc9c"><span class="section-number-4">12.2.1</span> System calls</h4>
<div class="outline-text-4" id="text-12-2-1">
<ul class="org-ul">
<li>Application wants to make a syscall in its guest OS</li>
<li>Syscall vectors for the physical machine in VMM</li>
<li>Syscall vectors for its OS in its guest OS</li>
<li>Harware direct systcalls to physical syscalls vectors</li>
<li>VMM must forward syscalls
<ul class="org-ul">
<li>VMM boot time: Install physical machine syscall vectors</li>
<li>OS boot time:
<ul class="org-ul">
<li>OS wants to install its syscall vectors</li>
<li>Privileged access from user mode</li>
<li>Traps to VMM</li>
<li>So VMM knows where they are</li>
</ul></li>
<li>System call Time
<ul class="org-ul">
<li>Hardware
<ul class="org-ul">
<li>Puts machine into kernel mode</li>
<li>Jumps to machine syscall handler</li>
</ul></li>
<li>VMM
<ul class="org-ul">
<li>Sets PC to appropriate syscall vector in OS</li>
<li>Returns to user mode</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgaf71d21" class="outline-5">
<h5 id="orgaf71d21"><span class="section-number-5">12.2.1.1</span> Execution summary</h5>
<div class="outline-text-5" id="text-12-2-1-1">
<p>
Native mode
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Application</th>
<th scope="col" class="org-left">Hardware</th>
<th scope="col" class="org-left">OS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">System call</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Switch to kernel mode</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">PC = syscall handler</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Run syscall handler</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Next PC = after syscall</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Return to user mode instruction</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Return to user mode</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Continue</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
Virtualized mode
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Application</th>
<th scope="col" class="org-left">Hardware</th>
<th scope="col" class="org-left">VMM</th>
<th scope="col" class="org-left">Guest OS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">System call</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Kernel Mode</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">PC = syscall handler</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Next PC = syscall handler in guest OS</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Return to user mode instruction</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">User mode</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">execute syscall</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">return to user mode instruction</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">kernel mode</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">PC = trap handler</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Trap handler</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Next PC = after syscall</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Return to user mode instruction</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">User mode</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Continue</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>Trap into VMM</li>
<li>VMM handles it</li>
<li>Returns to OS kernel (except for return to user mode)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2df9252" class="outline-4">
<h4 id="org2df9252"><span class="section-number-4">12.2.2</span> Protecting Guest OS memory</h4>
<div class="outline-text-4" id="text-12-2-2">
<ul class="org-ul">
<li>Application could access its guest OS memory</li>
</ul>
<p>
How to prevent?
</p>
<ul class="org-ul">
<li>On switching back from VMM to VM</li>
<li>If return address is in guest OS, allow all memory accesses within VM</li>
<li>If return address is outside guest OS, disallow access to guest OS memory</li>
<li>Done through protections in page tables</li>
</ul>
</div>
</div>
<div id="outline-container-orga95d902" class="outline-4">
<h4 id="orga95d902"><span class="section-number-4">12.2.3</span> Implementing virtual memory</h4>
<div class="outline-text-4" id="text-12-2-3">
<p>
Simplification using paging with valid bits
</p>
</div>
<div id="outline-container-orga8c267a" class="outline-5">
<h5 id="orga8c267a"><span class="section-number-5">12.2.3.1</span> Native mode</h5>
<div class="outline-text-5" id="text-12-2-3-1">
<ul class="org-ul">
<li>Process(or) issues virtual address\</li>
<li>Memory management produces physical address
<ul class="org-ul">
<li>Either from the TLB</li>
<li>Or from the page table</li>
</ul></li>
<li>Physical address goes to memory</li>
<li>OS allocates physical memory to processes</li>
<li>OS installs page table and TLB entries to do so</li>
</ul>
</div>
</div>
<div id="outline-container-orgd75afa1" class="outline-5">
<h5 id="orgd75afa1"><span class="section-number-5">12.2.3.2</span> Virtualized mode</h5>
<div class="outline-text-5" id="text-12-2-3-2">
<ul class="org-ul">
<li>VMM allocates memory between VMs</li>
<li>OS installs page table and TLB entries to do so</li>
<li>Guest OS thinks
<ul class="org-ul">
<li>It is running on the real machine</li>
<li>It has control over all memory of the real machine</li>
</ul></li>
<li>But, guest OS
<ul class="org-ul">
<li>Is running on a virtual machine</li>
<li>Has limited portion of memory (allocated by VMM)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1c33ca" class="outline-5">
<h5 id="orgb1c33ca"><span class="section-number-5">12.2.3.3</span> Terminology</h5>
<div class="outline-text-5" id="text-12-2-3-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Native mode</th>
<th scope="col" class="org-left">Virtualized mode</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Virtual address (VA)</td>
<td class="org-left">Virtual address (VA)</td>
</tr>

<tr>
<td class="org-left">Physical address (PA)</td>
<td class="org-left">Guest physical address (gPA)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Host physical address (hPA)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org3626585" class="outline-5">
<h5 id="org3626585"><span class="section-number-5">12.2.3.4</span> Two levels of translation</h5>
<div class="outline-text-5" id="text-12-2-3-4">
<ul class="org-ul">
<li>VA &rarr; gPA: managed by guest OS
<ul class="org-ul">
<li>Using guest TLB and guest page tables</li>
<li>One guest page table per process in guest OS</li>
<li>Resides in guest OS memory</li>
</ul></li>
<li>gPA &rarr; hPA: managed by VMM
<ul class="org-ul">
<li>Using physical TLB and physical page tables</li>
<li>One physical page table per VM on the machine</li>
<li>Resides in VMM memory</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7a083eb" class="outline-5">
<h5 id="org7a083eb"><span class="section-number-5">12.2.3.5</span> gPA &rarr; hPA translation</h5>
<div class="outline-text-5" id="text-12-2-3-5">
<ul class="org-ul">
<li>Done by the VMM</li>
<li>As done by the native OS before</li>
<li>Allocate a page to a VM
<ul class="org-ul">
<li>Find a free frame</li>
<li>Insert page-to-frame mapping in VM's page table</li>
<li>Insert mapping in TLB</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga5eb9fb" class="outline-5">
<h5 id="orga5eb9fb"><span class="section-number-5">12.2.3.6</span> VA &rarr; gPA</h5>
<div class="outline-text-5" id="text-12-2-3-6">
<ul class="org-ul">
<li>Guest OS does not change</li>
<li>So, allocate a new page to a process
<ul class="org-ul">
<li>Find a free frame (denoted by a gPA)</li>
<li>Insert page-frame mapping in process page table</li>
<li>Insert page-frame mapping in TLB</li>
</ul></li>
</ul>
<p>
Last two are privileged operations trap to VMM, VMM does insert into VM's
physical page table
</p>

<p>
Expensive, walk two level of page tables, one in the guest OS, one in the VMM
</p>
</div>
</div>
<div id="outline-container-org1768675" class="outline-5">
<h5 id="org1768675"><span class="section-number-5">12.2.3.7</span> Nested Page Tables</h5>
<div class="outline-text-5" id="text-12-2-3-7">
<ul class="org-ul">
<li>Available on modern processors</li>
<li>Allows to walk both sets of page tables
<ul class="org-ul">
<li>In parallel</li>
<li>In hardware</li>
</ul></li>
<li>Reduce cost of VM memory management</li>
<li>But adds complexity to hardware</li>
</ul>
</div>
</div>
</div>
</div>




















<div id="outline-container-orgc66ef56" class="outline-3">
<h3 id="orgc66ef56"><span class="section-number-3">12.3</span> Architecure-centric view of VMs: Popek/Goldberg Theorem</h3>
<div class="outline-text-3" id="text-12-3">
<p>
TODO watch <a href="https://www.youtube.com/watch?v=zckZkEF7elo">https://www.youtube.com/watch?v=zckZkEF7elo</a>
</p>
</div>
<div id="outline-container-org49251a6" class="outline-4">
<h4 id="org49251a6"><span class="section-number-4">12.3.1</span> Definitions</h4>
<div class="outline-text-4" id="text-12-3-1">
<ul class="org-ul">
<li>An instruction is <span class="underline">privileged</span> if it can only be executed in kernel mode</li>
<li>An instruction is <span class="underline">sensitive</span> if it behaves differently in kernel and user
mode</li>
</ul>
</div>
</div>
<div id="outline-container-orgdcdab6a" class="outline-4">
<h4 id="orgdcdab6a"><span class="section-number-4">12.3.2</span> Theorem</h4>
<div class="outline-text-4" id="text-12-3-2">
<p>
VMM exists for and architecture if and only if {sensitive} is a subset of
{privileged}
</p>
</div>
</div>
<div id="outline-container-org3ed10a4" class="outline-4">
<h4 id="org3ed10a4"><span class="section-number-4">12.3.3</span> Intuition</h4>
<div class="outline-text-4" id="text-12-3-3">
<ul class="org-ul">
<li>Implement "trap-and-emulate" VMM</li>
<li>VMM runs guest OS and apps in user mode</li>
<li>Guest OS: privileged instructions produce traps</li>
<li>VMM emulates these traps, guest OS thinks it is running in kernel mode</li>
<li>Everything else "still works"</li>
<li>If there were sensitive un-privileged instructions</li>
<li>Guest OS executes one of them</li>
<li>Behaves differently when guest OS in user mode</li>
<li>Semantics for guest OS is not maintained</li>
</ul>
</div>
</div>
<div id="outline-container-orgff756a7" class="outline-4">
<h4 id="orgff756a7"><span class="section-number-4">12.3.4</span> Satisfaction of the theorem</h4>
<div class="outline-text-4" id="text-12-3-4">
<ul class="org-ul">
<li>x86 &rarr; nope</li>
<li>Vmware, workaround: binary rewrite guest OS to remove such sensitive
unprivileged instructions, tricky&#x2026;</li>
<li>Intel VT-x and AMD-v
<ul class="org-ul">
<li>Meets Popek/Goldberg theorem</li>
<li>Available on all current 64-bit processors</li>
<li>Used by all virtualization solutions today</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2e984b9" class="outline-3">
<h3 id="org2e984b9"><span class="section-number-3">12.4</span> Paravirtualization</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>VMM provides interface
<ul class="org-ul">
<li><i>Almost</i> like the real machine</li>
<li><i>But not quite</i></li>
</ul></li>
<li>Requires limited changes to guest OS</li>
<li>But can offer better performances</li>
</ul>
</div>
</div>
<div id="outline-container-org6ef714b" class="outline-3">
<h3 id="org6ef714b"><span class="section-number-3">12.5</span> Conclusion</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li>VMs again popular, mainly because server provisioning and consolidation</li>
<li>New x86 architectures facilitate efficient VMMS
<ul class="org-ul">
<li>Meet Popek/Goldberg theorem</li>
<li>Additional architectural support</li>
</ul></li>
<li>Cost and complexity remain to some extent
<ul class="org-ul">
<li>System calls, virtual memory</li>
<li>Also in I/O, especially networking</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2017-05-26 Fri 18:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
