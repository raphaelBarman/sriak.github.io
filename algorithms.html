<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2015-11-01 Sun 14:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Algorithms</title>
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="css/hideshow.css"/>
<link rel="stylesheet" type="text/css" href="css/navbar.css"/>
<script type="text/javascript" src="js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="js/bigblow.js"></script>
<script type="text/javascript" src="js/hideshow.js"></script>
<script type="text/javascript" src="js/jquery.stickytableheaders.min.js"></script>
<link rel="stylesheet" type="text/css" href="css/slider.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Algorithms</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline3">1. Week 1</a>
<ul>
<li><a href="#orgheadline1">1.1. Definition of algorithm</a></li>
<li><a href="#orgheadline2">1.2. Instance of a problem</a></li>
</ul>
</li>
<li><a href="#orgheadline14">2. Week 2</a>
<ul>
<li><a href="#orgheadline4">2.1. Insertion sort algorithm</a></li>
<li><a href="#orgheadline7">2.2. Loop Invariant -&gt; prove corectness of algorithm</a>
<ul>
<li><a href="#orgheadline5">2.2.1. Example 1 : Sum up to <i>n</i></a></li>
<li><a href="#orgheadline6">2.2.2. Example 2 : Insertion sort</a></li>
</ul>
</li>
<li><a href="#orgheadline13">2.3. Divide and conquer approach</a>
<ul>
<li><a href="#orgheadline8">2.3.1. Principle :</a></li>
<li><a href="#orgheadline11">2.3.2. Application on merge and sort :</a>
<ul>
<li><a href="#orgheadline9">2.3.2.1. Corectness</a></li>
<li><a href="#orgheadline10">2.3.2.2. Time analysis</a></li>
</ul>
</li>
<li><a href="#orgheadline12">2.3.3. Analysis of divide-and-conquer algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline18">3. Week 3</a>
<ul>
<li><a href="#orgheadline15">3.1. The substitution method</a></li>
<li><a href="#orgheadline16">3.2. The recursion tree method</a></li>
<li><a href="#orgheadline17">3.3. The master method</a></li>
</ul>
</li>
<li><a href="#orgheadline31">4. Week 4</a>
<ul>
<li><a href="#orgheadline23">4.1. Maximum-subarray problem</a>
<ul>
<li><a href="#orgheadline19">4.1.1. Brute force</a></li>
<li><a href="#orgheadline22">4.1.2. Divide and conquer</a>
<ul>
<li><a href="#orgheadline20">4.1.2.1. Time analysis</a></li>
<li><a href="#orgheadline21">4.1.2.2. Crossing subarray</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline30">4.2. Matrix multiplication</a>
<ul>
<li><a href="#orgheadline24">4.2.1. Naive algorithm</a></li>
<li><a href="#orgheadline27">4.2.2. Divide-and-Conquer</a>
<ul>
<li><a href="#orgheadline25">4.2.2.1. Pseudocode</a></li>
<li><a href="#orgheadline26">4.2.2.2. Analysis</a></li>
</ul>
</li>
<li><a href="#orgheadline29">4.2.3. Strassen's algorithm</a>
<ul>
<li><a href="#orgheadline28">4.2.3.1. Time analysis</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline62">5. Week 5</a>
<ul>
<li><a href="#orgheadline38">5.1. Heap</a>
<ul>
<li><a href="#orgheadline32">5.1.1. Root :</a></li>
<li><a href="#orgheadline33">5.1.2. Height :</a></li>
<li><a href="#orgheadline34">5.1.3. Storage :</a></li>
<li><a href="#orgheadline37">5.1.4. Operations</a>
<ul>
<li><a href="#orgheadline35">5.1.4.1. MAX-HEAPIFY</a></li>
<li><a href="#orgheadline36">5.1.4.2. Building a heaps</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline41">5.2. Heapsort</a>
<ul>
<li><a href="#orgheadline39">5.2.1. Pseudocode :</a></li>
<li><a href="#orgheadline40">5.2.2. Analysis</a></li>
</ul>
</li>
<li><a href="#orgheadline46">5.3. Priorty queue</a>
<ul>
<li><a href="#orgheadline45">5.3.1. Operations</a>
<ul>
<li><a href="#orgheadline42">5.3.1.1. HEAP-MAXIMUM</a></li>
<li><a href="#orgheadline43">5.3.1.2. HEAP-EXTRACT-MAX(A,n)</a></li>
<li><a href="#orgheadline44">5.3.1.3. HEAP-INCREASE-KEY(A,i,key)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline49">5.4. Stacks</a>
<ul>
<li><a href="#orgheadline47">5.4.1. Implementation</a></li>
<li><a href="#orgheadline48">5.4.2. Operations</a></li>
</ul>
</li>
<li><a href="#orgheadline52">5.5. Queue</a>
<ul>
<li><a href="#orgheadline50">5.5.1. Implementation</a></li>
<li><a href="#orgheadline51">5.5.2. Operations</a></li>
</ul>
</li>
<li><a href="#orgheadline55">5.6. Stacks and queues</a>
<ul>
<li><a href="#orgheadline53">5.6.1. Pros</a></li>
<li><a href="#orgheadline54">5.6.2. Cons</a></li>
</ul>
</li>
<li><a href="#orgheadline61">5.7. Linked list</a>
<ul>
<li><a href="#orgheadline56">5.7.1. Searching in a linked list</a></li>
<li><a href="#orgheadline57">5.7.2. Inserting into a linked list</a></li>
<li><a href="#orgheadline58">5.7.3. Deleting from a linked list</a></li>
<li><a href="#orgheadline59">5.7.4. <span class="todo nilTODO">TODO</span> Using Sentinels</a></li>
<li><a href="#orgheadline60">5.7.5. Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline95">6. Week 6</a>
<ul>
<li><a href="#orgheadline72">6.1. Binary Search trees</a>
<ul>
<li><a href="#orgheadline63">6.1.1. Searching</a></li>
<li><a href="#orgheadline64">6.1.2. Min and Max</a></li>
<li><a href="#orgheadline65">6.1.3. Sucessor and Predecessor</a></li>
<li><a href="#orgheadline68">6.1.4. Printing</a>
<ul>
<li><a href="#orgheadline66">6.1.4.1. Inorder</a></li>
<li><a href="#orgheadline67">6.1.4.2. Preorder and Postorder</a></li>
</ul>
</li>
<li><a href="#orgheadline71">6.1.5. Modifying</a>
<ul>
<li><a href="#orgheadline69">6.1.5.1. Inserting</a></li>
<li><a href="#orgheadline70">6.1.5.2. Deleting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline74">6.2. Dynamic programming</a>
<ul>
<li><a href="#orgheadline73">6.2.1. Key element in designing a DP-algorithm</a></li>
</ul>
</li>
<li><a href="#orgheadline77">6.3. Fibonacci numbers</a>
<ul>
<li><a href="#orgheadline75">6.3.1. Memoization</a></li>
<li><a href="#orgheadline76">6.3.2. Bottom-updates</a></li>
</ul>
</li>
<li><a href="#orgheadline86">6.4. Rod cutting</a>
<ul>
<li><a href="#orgheadline78">6.4.1. Size of the problem</a></li>
<li><a href="#orgheadline79">6.4.2. Structural theorem</a></li>
<li><a href="#orgheadline80">6.4.3. First algorithm</a></li>
<li><a href="#orgheadline81">6.4.4. Top-down algorithm</a></li>
<li><a href="#orgheadline82">6.4.5. Bottom-up</a></li>
<li><a href="#orgheadline83">6.4.6. Analysis</a></li>
<li><a href="#orgheadline84">6.4.7. Optimal solution</a></li>
<li><a href="#orgheadline85">6.4.8. Summary</a></li>
</ul>
</li>
<li><a href="#orgheadline94">6.5. Matrix-chain multiplication</a>
<ul>
<li><a href="#orgheadline87">6.5.1. Cost of matrix multiplication</a></li>
<li><a href="#orgheadline88">6.5.2. Definition</a></li>
<li><a href="#orgheadline89">6.5.3. Optimal substructure</a></li>
<li><a href="#orgheadline90">6.5.4. Recursive formula</a></li>
<li><a href="#orgheadline91">6.5.5. Bottom-up algorithm</a></li>
<li><a href="#orgheadline92">6.5.6. Print optimal solution</a></li>
<li><a href="#orgheadline93">6.5.7. Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline110">7. Week 7</a>
<ul>
<li><a href="#orgheadline103">7.1. Longest common subsequence</a>
<ul>
<li><a href="#orgheadline96">7.1.1. Brute force</a></li>
<li><a href="#orgheadline102">7.1.2. Dynamic programming</a>
<ul>
<li><a href="#orgheadline97">7.1.2.1. Choice</a></li>
<li><a href="#orgheadline98">7.1.2.2. Optimal substructure</a></li>
<li><a href="#orgheadline99">7.1.2.3. Recursive formulation</a></li>
<li><a href="#orgheadline100">7.1.2.4. Bottom-up pseudocode</a></li>
<li><a href="#orgheadline101">7.1.2.5. Printing solution pseudocode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline109">7.2. Optimal binary search trees</a>
<ul>
<li><a href="#orgheadline104">7.2.1. Idea</a></li>
<li><a href="#orgheadline105">7.2.2. Observations</a></li>
<li><a href="#orgheadline106">7.2.3. Optimal substructure</a></li>
<li><a href="#orgheadline107">7.2.4. Recursive formulation</a></li>
<li><a href="#orgheadline108">7.2.5. Bottom-up pseudocode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">1</span> Week 1</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> Definition of algorithm</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Relation between an input and an ouptut</li>
<li>Tool to solve a computational problem</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> Instance of a problem</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Input of the problem. 
Examples :
</p>
<ul class="org-ul">
<li>Sorting problem, instance : &lt;32,54,65,23,54&gt;</li>
<li>Sum of all numbers to <i>n</i> : 4, <i>n</i> &ne; instance</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">2</span> Week 2</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">2.1</span> Insertion sort algorithm</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">2</span> to A.length
  key = A<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">Insert A[j] into the sorted sequance A[1..j-1]</span>
  i = j -<span style="color: #268bd2; font-weight: bold;">1</span>
  <span style="color: #859900; font-weight: bold;">while</span> i &gt; <span style="color: #268bd2; font-weight: bold;">0</span> and A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> &gt; key
    A<span style="color: #2aa198;">[</span>i+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> = A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
    i = i -<span style="color: #268bd2; font-weight: bold;">1</span>
  A<span style="color: #2aa198;">[</span>i+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> = key
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">2.2</span> Loop Invariant -&gt; prove corectness of algorithm</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Loop invariant : "a statement that is satisfied during the loop"</li>
<li>Need to verify :
<ul class="org-ul">
<li><b>Initialization</b> : True at the beginning of the 1st iteration of the loop</li>
<li><b>Maintenance</b> :  If it is true before an iteration of of the loop, it remains
true before the next iteration</li>
<li><b>Termination</b> : When the loop terminates, the invariant gives us a useful
property that helps show that the algorithm is correct</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">2.2.1</span> Example 1 : Sum up to <i>n</i></h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
The algorithm is the following : <br  />
<b>CalculateSum</b> (<i>n</i>):
</p>
<div class="org-src-container">

<pre class="src src-java">ans = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span>,<span style="color: #268bd2; font-weight: bold;">2</span>,..,<span style="color: #b58900;">n</span>
 <span style="color: #268bd2;">ans</span> = ans + i
<span style="color: #859900; font-weight: bold;">return</span> ans
</pre>
</div>
<ul class="org-ul">
<li><b>Loop invariant</b> : At the start of each iteration \(ans = (i-1) * i/2\)</li>
<li><b>Initialization</b> : At the begining of the first iteration, \(i =1\) and \(ans =
  0 = i(i -1)/2)\) so the invariant is satisfied</li>
<li><b>Maintenance</b> : Suppose invariant true at the beginning of iteration when
\(i=k\), i.e, \(ans = (k-1)k/2\). Then the iteration updates \(ans\) by adding \(k\),
i.e., \(ans = (k-1)k/2 +k = k(k+1)/2\) so incrementing \(i\) then for next
iteration preserves the loop invariant.</li>
<li><b>Termination</b> : When the loop terminates \(i=n+1\). Hence the algorithm returns
\(ans = n(n+1)/2\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">2.2.2</span> Example 2 : Insertion sort</h4>
<div class="outline-text-4" id="text-2-2-2">
<input checked type=radio name=slider id=slide1 />
    <input type=radio name=slider id=slide2 />
    <input type=radio name=slider id=slide3 />
    <input type=radio name=slider id=slide4 />
  
  
    <!-- The Slider -->
    
    <div id=slides>
    
      <div id=overflow>
      
        <div class=inner>
        
          <article>
            <img src=pdf/insertionsortproof-0.jpg />
          </article>
          
          <article>
            <img src=pdf/insertionsortproof-1.jpg />
          </article>
          
          <article>
            <img src=pdf/insertionsortproof-2.jpg />
          </article>
          
          <article>
            <img src=pdf/insertionsortproof-3.jpg />
          </article>
          
        </div> <!-- .inner -->
        
      </div> <!-- #overflow -->
    
    </div> <!-- #slides -->
  
  
    <!-- Controls and Active Slide Display -->
  
    <div id=controls>

      <label for=slide1></label>
      <label for=slide2></label>
      <label for=slide3></label>
      <label for=slide4></label>
    
    </div> <!-- #controls -->
    
    <div id=active>

      <label for=slide1></label>
      <label for=slide2></label>
      <label for=slide3></label>
      <label for=slide4></label>
      
    </div> <!-- #active -->
</div>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">2.3</span> Divide and conquer approach</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><span class="section-number-4">2.3.1</span> Principle :</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li><b>Divide</b> the problem into a number of subproblems that are smaller instances
of the same problem</li>
<li><b>Conquer</b> the subproblems by solving them recursively. If the subproblem sizes
are small enough, however, just solve the subproblems in a straightforwad
manner</li>
<li><b>Combine</b> the solutions to the subproblems into the solution for the original problem</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">2.3.2</span> Application on merge and sort :</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
To sort \(A[p...r]\):
</p>
<ul class="org-ul">
<li><b>Divide</b> by splitting into two subarrays \(A[p...q]\) and \(A[q+1,...r]\), whre
\(q\) is the halfway point of \(A[p..r]\)</li>
<li><b>Conquer</b> by recursively sorting the two subarrays \(A[p..q]\) and \(A[q+1,...r]\)</li>
<li><b>Combine</b> by mergie the two sorted subarrays \(A[p...q]\) and \(A[q+1,...r]\) to
produce a single sorted subarray \(A[p...r]\)</li>
</ul>

<p>
<b>Merge-Sort</b> \((A,p,r)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> p &lt; <span style="color: #b58900;">r</span>  <span style="color: #586e75;">//</span><span style="color: #586e75;">check for base case</span>
  q = floor<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>p+r<span style="color: #b58900;">)</span>/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>  <span style="color: #586e75;">// </span><span style="color: #586e75;">divide</span>
  Merge-Sort<span style="color: #2aa198;">(</span>A,p,q<span style="color: #2aa198;">)</span>  <span style="color: #586e75;">// </span><span style="color: #586e75;">conquer</span>
  Merge-Sort<span style="color: #2aa198;">(</span>A,q+<span style="color: #268bd2; font-weight: bold;">1</span>,r<span style="color: #2aa198;">)</span>  <span style="color: #586e75;">//</span><span style="color: #586e75;">conquer</span>
  Merge<span style="color: #2aa198;">(</span>A,p,q,r<span style="color: #2aa198;">)</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">combine</span>
</pre>
</div>
<p>
<b>Merge</b> (\(A\),\(p\),\(q\),\(r\))
</p>
<div class="org-src-container">

<pre class="src src-java">n_1 = q - p + <span style="color: #268bd2; font-weight: bold;">1</span>
n_2 = r - q
let L<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span>..n_1+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> and R<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span>..n_2+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> be <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">arrays</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n_1
  L<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = A<span style="color: #2aa198;">[</span>p+i-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">1</span> to n_2
  R<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span> = A<span style="color: #2aa198;">[</span>q+j<span style="color: #2aa198;">]</span>
L<span style="color: #2aa198;">[</span>n_1+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>= infinity
R<span style="color: #2aa198;">[</span>n_2 +<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>= infinity
i = <span style="color: #268bd2; font-weight: bold;">1</span>
j = <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">for</span> k = p to r
  <span style="color: #859900; font-weight: bold;">if</span> L<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> &lt;= R<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
    A<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span> = L<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
    i = i +<span style="color: #268bd2; font-weight: bold;">1</span>
  <span style="color: #859900; font-weight: bold;">else</span>
    A<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span> = R<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
    j = j +<span style="color: #268bd2; font-weight: bold;">1</span>
</pre>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-5">
<h5 id="orgheadline9"><span class="section-number-5">2.3.2.1</span> Corectness</h5>
<div class="outline-text-5" id="text-2-3-2-1">
<ul class="org-ul">
<li>What does merge(A,p,q,r) do ?
<ul class="org-ul">
<li>It takes array \(A\) and indexes \(p \le q < r\) s.t. \(A[p...q]\) and \(A[q+1...r]\) are sorted.</li>
<li>Then it outputs \(A[p...r]\) contains the same elements in sorted order</li>
</ul></li>
<li>Proof by induction on \(n = r - p\) :
<ul class="org-ul">
<li>Base case : \(n = 0\), in this case \(r = p\) so \(A[p...r]\) (single element) is trivially sorted.</li>
<li>Inductive case : assume statement true \(\forall\ n \in \{0,1,...,n-1\}\) and
prove true for \(n=k\)
<ul class="org-ul">
<li>By induction hypothesis ( \(q - p < n\) ) Merge-Sort(A,p,q) and
Merge-Sort(A,q+1,r) sucessfully sort the two subarrays.</li>
<li>Therefore a correct merge procedure will sucessfully sort \(A[p...q]\) as required.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-5">
<h5 id="orgheadline10"><span class="section-number-5">2.3.2.2</span> Time analysis</h5>
<div class="outline-text-5" id="text-2-3-2-2">

<div class="figure">
<p><img src="pdf/mergesorttime.jpg" alt="mergesorttime.jpg" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">2.3.3</span> Analysis of divide-and-conquer algorithms</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Use a <b>recurrence</b> equation to describe the running time :
</p>
<ul class="org-ul">
<li>Let \(T(n)\) = "running time on a problem of size \(n\)"</li>
<li>If \(n\) is small enough say \(n\le c\) for some constant \(c\) then \(T(n) = \Theta(1)\) (by brute force)</li>
<li>Otherwise, suppose we divide into \(a\) sub problems each size \(n/b\) (conquer step)</li>
<li>Let \(D(n)\) be the time to divide and let \(C(n)\) the time to combine solutions</li>
<li>We get the reccurence : \(T(n) = \Theta(1)\) if \(n\le c\), else \(T(n) = aT(n/b)+D(n)+C(n)\)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">3</span> Week 3</h2>
<div class="outline-text-2" id="text-3">
<p>
Consider the following recurrence :
</p>

<p>
\(T(n) = c\) if \(n = 1\) <br  />
\(T(n) = 2T(n/2) + c \cdot n\) otherwise
</p>

<p>
Note that this reccurence upper bounds and lower bounds the reccurence for
Merge-Sort by selecting \(c\) sufficiently large and small, respectively.
</p>

<p>
Three solving techiques :
</p>
</div>
<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">3.1</span> The substitution method</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>Guess the form of the solution</li>
<li>Use mathematical induction to find the constant (substition method in the book)</li>
</ol>

\begin{align*} T(n) &= 2T(n/2) + c \cdot n \\
&= 2(2T (n/4) + c \cdot n/2) + c \cdot n = 4T(n/4) + 2 \cdot c \cdot n\\
&= 4(2T (n/8) + c \cdot n/4) + 2 \cdot c \cdot n =  8T(n/8) + 3 \cdot c \cdot n\\
&\vdots \\
&= 2^k T(n/2^k) + k \cdot c \cdot n
\end{align*}

<p>
A qualified guess is that \(T(n) = \Theta (n \log n)\).
</p>
<ul class="org-ul">
<li>and show that the solution works
<ul class="org-ul">
<li>First upper bound :
We want to prove there exists \(a > 0\) s.t \(T(n) \le a \cdot n \cdot \log n\)
\(\forall n \ge 2\)
<ul class="org-ul">
<li><b>Base case</b> : For any constant \(n \in \{2,3,4\}\), \(T(n)\) has a constant
value, selecting a larger than this value will satisfy the base cases when
\(n \in \{2,3,4\}\).</li>
<li><p>
<b>Inductive step</b> : <i>Assume statement true \(\forall n \{2,3,...,k-1\}\) and
prove the statement for \(n=k\)</i>
</p>
\begin{align*}
T(n) &= 2T(n/2) + c \cdot n \\
&\le 2 \cdot \frac{an}{2} \log(n/2) + c \cdot n = a \cdot n \log(n/2) + c \cdot n \\
&= a \cdot n \log n -a \cdot n + c \cdot n \\
&\le a \cdot n \log n \text{ (if we select $a \ge c$)}
\end{align*}
<p>
We can thus select \(a\) to be a positive constant so taht both the base
cases and the inductive step holds. Hence, \(T(n) = O(n\log n)\).
</p></li>
</ul></li>
<li>Second lower bound :
<ul class="org-ul">
<li>We want to prove there exists a constant \(b > 0\) s.t \(T(n) \ge b \cdot n
      \cdot \log n\) \(\forall n \ge 0\)</li>
<li><b>Base case</b> : For \(n=1,T(n)=c\) and \(b \cdot n \log n =0\) so the base case
is satisfied for any b.</li>
<li><p>
<b>Inductive step</b> : <i>Assume statement true \(\forall n \in \{0,1,...,k-1\}\)
      and prove the statement for \(n =k\)</i>
</p>
\begin{align*}
T(n) &= 2T (n/2) + c \cdot n\\
&\ge 2 \cdot \frac{b\cdot n}{2} \log(n/2) + c \cdot n = b \cdot n \log(n/2) + c \cdot n\\
&= b \cdot n \log n - b \cdot n + c \cdot n \\
& \ge b \cdot n \log n \text{ (if we select $b \le c$)}
\end{align*}</li>
</ul></li>
</ul></li>
</ul>
<p>
We can thus select \(b\) to be positive constant so that both the base cases and
the inductive step holds. Hence, \(T(n) = \Omega(n\log n)\).
</p>

<ul class="org-ul">
<li>Other example</li>
</ul>
<p>
Prove that \(T(n) = O(n)\)
First \(\exists c\) s.t.
</p>
\begin{align*}
 T(n) \le F(n)\\
\text{and}\\
F(n) = c \text{ if $n=0, n=1$, else } F(\frac{n}{4} +1 ) + F(\frac{3n}{4} -1) + c
\end{align*} 
<p>
We shall prove that \(F(n) = O(n)\)
claim : there exists constants \(b',b > 0\) and \(n_0 \ge 0\) s.t. \( \forall n \ge n_0\)
\(F(n) \le b \cdot n - b'\)
</p>

<p>
Proof : Inductive step : Assume \(F(n) = b \cdot n\) \(\forall n \in
\{n_0,...k-1\}\) prove true for \(n=k\).
</p>
\begin{align*}
 F(n) &= F(\frac{n}{4} +1) + F(\frac{3n}{4} -1) + C \\
&= b(\frac{n}{4} + 1) b' + b (\frac{3n}{4} -1) b' + C\\
&= b \cdot n + c - 2b'\\
&\le b \cdot n - b' \text{ if $ b' \ge C$}
\end{align*}

<ul class="org-ul">
<li>Again other example :</li>
</ul>
<p>
\(T(n) = \Theta(1)\) if \(n=1\) <br  />
\(8 T(n/2) + c \cdot n^2\) if \(n > 1\) <br  />
Prove that \(T(n)\) is \(O(n^3)\).
</p>

<p>
<span class="underline">Claim</span> : \(\exists d > 0\) and \(n_0 > 0\) s.t. \(T(n) \le d n^3 \forall n \ge n_0\)
</p>

<p>
<span class="underline">Base case</span>: for \(n=1,...,k\)
\(T(1), T(2) ... T(k)\) I can always select \(d \ge max \left\lbrace T(1), T(2),...
T(k) \right\rbrace\)
</p>

<p>
_<sub>Inductive</sub> step__ :
</p>
\begin{align*}
T(n) = 8 \cdot T(n/2) + c \cdot n^2 \\
\le 8 \cdot d \cdot (n/2)^3 + c \cdot n^2 \\
= d \cdot n^3 + c \cdot n^2
\end{align*}
<p>
How to remove the low order terms ? We add to our claim a \(-d' \cdot n^2\) s.t.
\(T(n) \le d n^3 - d' \cdot n^2 \forall n \ge n_0\).
Now
</p>
\begin{align*}
T(n) = 8 \cdot T(n/2) + c \cdot n^2 \\
\le d \cdot n^3 - 2 \cdot d' \cdot n^2 + c \cdot n^2\\
\le d \cdot n^3 - d' \cdot n^2 \text{if $d' \ge c$}
\end{align*}
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">3.2</span> The recursion tree method</h3>
<div class="outline-text-3" id="text-3-2">
<input checked type=radio name=slider id=slide01 />
    <input type=radio name=slider id=slide02 />
    <input type=radio name=slider id=slide03 />
  
  
    <!-- The Slider -->
    
    <div id=slides>
    
      <div id=overflow>
      
        <div class=inner>
        
          <article>
            <img src=pdf/recursiontree01.jpg />
          </article>
          
          <article>
            <img src=pdf/recursiontree02.jpg />
          </article>
          
          <article>
            <img src=pdf/recursiontree03.jpg />
          </article>
          
        </div> <!-- .inner -->
        
      </div> <!-- #overflow -->
    
    </div> <!-- #slides -->
  
  
    <!-- Controls and Active Slide Display -->
  
    <div id=controls>

      <label for=slide01></label>
      <label for=slide02></label>
      <label for=slide03></label>
    
    </div> <!-- #controls -->
    
    <div id=active>

      <label for=slide01></label>
      <label for=slide02></label>
      <label for=slide03></label>
      
    </div> <!-- #active -->
<ul class="org-ul">
<li>Examples to do with this method :
<ul class="org-ul">
<li>\(T(n) = 2 T(n/2) + c \cdot n^2\), cost of base root \(cn^2\), but cost of last
root : \(cn\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">3.3</span> The master method</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Used to black-box solve reccurences of form \(T(n) = a \cdot T(n/b) + f(n)\)
(doesn't work with \(T(n) = T(n/3) + T(2n/3) + cn\) for example).
</p>

<p>
<span class="underline">Theorem (Master theorem)</span>
</p>

<p>
Let \(a \ge 1\) and \(b > 1\) be constants, let \(T(n)\) be defined on the
  nonnegative integers by the reccurence :
</p>
\begin{align*}
T(n) = a \cdot T(n/b) + f(n)
\end{align*}
<p>
Then, \(T(n)\) has the following asymptotic bounds :
</p>
<ul class="org-ul">
<li>If \(f(n) = O(n^{\log_b a- \epsilon})\) for some constant \(\epsilon > 0\), then
\(T(n) = \Theta(n^{\log_b a})\)</li>
<li>If \(f(n) = \Theta(n^{\log_b a})\), then \(T(n) = \Theta(n^{\log_b a} \log n)\)</li>
<li>If \(f(n) = \Omega(n^{\log_b a+\epsilon})\) for some constant \(\epsilon > 0\) and
if \(a \cdot f(n/b) \le c \cdot f(n)\) for some constant \(c < 1\) and all
sufficiently large \(n\), then \(T(n) = \Theta(f(n))\)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline31" class="outline-2">
<h2 id="orgheadline31"><span class="section-number-2">4</span> Week 4</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">4.1</span> Maximum-subarray problem</h3>
<div class="outline-text-3" id="text-4-1">
<p>
"If we let \(A[i]\) = (price after day \(i\)) - (price after day \(i-1\)) then if the
maximum subarray is \(A[i..j]\) then we should have bought just before day \(i\) and
sold just after day \(j\).
</p>

<p>
<b>Input</b> : An array \(A[1...n]\) of numbers
</p>

<p>
<b>Output</b> Indices \(i\) and \(j\) such that \(A[i...j]\) has the greatest sum of any
 nonempty, contiguous subarray of \(A\), along with the sum of the values in \(A[i...j]\).
</p>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19"><span class="section-number-4">4.1.1</span> Brute force</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Simply check all possible subarrays.
</p>

<p>
\(\binom{n}{2} =  \Theta (n^2)\) many.
</p>

<p>
<b>Maximum-subarray-slow</b> \((A[1...n])\)
</p>
<div class="org-src-container">

<pre class="src src-java">B.val = - infinity, B.i = <span style="color: #268bd2; font-weight: bold;">1</span>, B.j = n
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  tmp = <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">for</span> j = i to n
    tmp = tmp + A<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">if</span> tmp &gt; B.val
       B.val = tmp
       B.i = i
       B.j = j
<span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>B.i,<span style="color: #268bd2; font-weight: bold;">B</span>.<span style="color: #268bd2; font-weight: bold;">j</span>.B.val<span style="color: #2aa198;">)</span>
</pre>
</div>
<p>
Running time is \(\Theta(n^2)\) and we use \(\Theta(n)\) space.
</p>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">4.1.2</span> Divide and conquer</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li><b>Divide</b> the subarray into two subarrays of as equal size as possible. Find the midpoint mid of the subarrays, and consider the subarrays \(A\)[low.. mid]
and \(A\)[mid+1&#x2026;high].</li>
<li><b>Conquer</b> by finding maximum subarrays of \(A\)[low . . . mid] and \(A\)[mid + 1 . . . high].</li>
<li><p>
<b>Combine</b> by finding a maximum subarray that crosses the midpoint,and using the best solution out of the three
</p>

<p>
<b>FIND-MAXIMUM-SUBARRAY</b> \((A,low,high)\)
</p></li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> high == low
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>low, high, A<span style="color: #b58900;">[</span>low<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">base case: only one element</span>
<span style="color: #859900; font-weight: bold;">else</span> mid = ceil<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>low + high<span style="color: #b58900;">)</span>/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>
  <span style="color: #2aa198;">(</span>left-low, left-high, left-sum<span style="color: #2aa198;">)</span> =
    FIND-MAXIMUM-SUBARRAY<span style="color: #2aa198;">(</span>A, low, mid<span style="color: #2aa198;">)</span>
  <span style="color: #2aa198;">(</span>right-low, right-high, right-sum<span style="color: #2aa198;">)</span> =
    FIND-MAXIMUM-SUBARRAY<span style="color: #2aa198;">(</span>A, mid + <span style="color: #268bd2; font-weight: bold;">1</span>, high<span style="color: #2aa198;">)</span>
  <span style="color: #2aa198;">(</span>cross-low, cross-high, cross-sum<span style="color: #2aa198;">)</span> =
    FIND-MAXIMUM-CROSSING-SUBARRAY<span style="color: #2aa198;">(</span>A,low,mid,high<span style="color: #2aa198;">)</span> 
  <span style="color: #859900; font-weight: bold;">if</span> left-sum &gt;= right-sum and left-sum &gt;= cross-sum
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>left-low, left-high, left-sum<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> right-sum &gt;= left-sum and right-sum &gt;= cross-sum
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>right-low, right-high, right-sum<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>cross-low, cross-high, cross-sum<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-5">
<h5 id="orgheadline20"><span class="section-number-5">4.1.2.1</span> Time analysis</h5>
<div class="outline-text-5" id="text-4-1-2-1">
<p>
Assume that we can find max-crossing-subarray in time \(\Theta(n)\) :
</p>

<ul class="org-ul">
<li><b>Divide</b> takes constant time, i.e, \(D(n) = \Theta(1)\)</li>
<li><b>Combine</b> time dominated by find-max-crossing-subarray, \(C(n) = \Theta(n)\)</li>
<li><b>Conquer</b> recusively solve two subproblems, each of size \(n/2\), \(T(n/2)\).</li>
</ul>

\begin{align*}
T(n) &= \Theta(1) \text{  if $n=1$}\\
T(n) &= 2T(n/2)+\Theta(n) \text{  otherwise}
\end{align*}
<p>
so \(T(n)=\Theta)n \log n)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-5">
<h5 id="orgheadline21"><span class="section-number-5">4.1.2.2</span> Crossing subarray</h5>
<div class="outline-text-5" id="text-4-1-2-2">
<ul class="org-ul">
<li>Any subarray crossing the midpoint A[mid] is made of two subarrays \(A[i...mid]\) and \(A[mid + 1,...,j]\) where \(low \le i \le mid\) and \(mid < j \le high\)</li>
<li>Find maximum subarrays of the form \(A[i...mid]\) and \(A[mid + 1...j]\) and then combine them.</li>
</ul>
<p>
<b>FIND-MAXIMUM-CROSSING-SUBARRAY</b> \((A,low,mid,high)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #586e75;">//</span><span style="color: #586e75;">Find a maximum subarray of the form A[i...mid]</span>
left-sum = - infinity
sum = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> i = mid downto low
  sum = sum + A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">if</span> sum &gt; left-sum
    left-sum = sum
    max-left = i
<span style="color: #586e75;">//</span><span style="color: #586e75;">Find a maximum subarray of the form A[mid+1...j]</span>
right-sum = - infinity
sum = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> j = mid + <span style="color: #268bd2; font-weight: bold;">1</span> to high
  sum = sum + A<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">if</span> sum &gt; right-sum
    right-sum = sum
    max-right = j
<span style="color: #586e75;">// </span><span style="color: #586e75;">Return the indices and the sum of the two subarrays.</span>
<span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">(</span>max-left, max-right, left-sum + right-sum<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">4.2</span> Matrix multiplication</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Multiply two \(n\times n\) matrices. \(AB=C\)
</p>

<p>
\(c_{ij} = \sum\limits_{k=1}^n a_{ik}b_{kj}\)
</p>
</div>

<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">4.2.1</span> Naive algorithm</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
<b>SQUARE-MAT-MULT</b> \((A,B,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java">let C <span style="color: #b58900;">be</span> <span style="color: #268bd2;">a</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">n</span> x n matrix
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  <span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">1</span> to n
    cij = <span style="color: #268bd2; font-weight: bold;">0</span>
    <span style="color: #859900; font-weight: bold;">for</span> k = <span style="color: #268bd2; font-weight: bold;">1</span> to n
      cij = cij + aik*bkj
<span style="color: #859900; font-weight: bold;">return</span> C
</pre>
</div>
<p>
Running time : \(\Theta(n^3)\)
</p>

<p>
Space : \(\Theta(n^2)\)
</p>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">4.2.2</span> Divide-and-Conquer</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li><b>Divide</b> each of \(A,B,C\) into four \(n/2 \times n/2\) matrices: so that :</li>
</ul>
\begin{align*}
  \begin{pmatrix}
  C_{11} & C_{12}\\
  C_{21} & C_{22}
  \end{pmatrix} = \begin{pmatrix}
  A_{11} & A_{12}\\
  A_{21} & A_{22}
  \end{pmatrix} \cdot \begin{pmatrix}
  B_{11} & B_{12}\\
  B_{21} & B_{22}
  \end{pmatrix}
\end{align*}
<ul class="org-ul">
<li><b>Conquer</b> : Since</li>
</ul>
\begin{align*}
C_{11} =  A_{11} \cdot B_{11} + A_{12} \cdot B_{21}\\
C_{12} =  A_{11} \cdot B_{12} + A_{12} \cdot B_{22}\\
C_{21} =  A_{21} \cdot B_{11} + A_{22} \cdot B_{21}\\
C_{22} =  A_{21} \cdot B_{12} + A_{22} \cdot B_{22}
\end{align*}
<p>
We recursively solve 8 matrix multiplications that each multiply two \(n/2 \times
n/2\) matrices.
</p>
<ul class="org-ul">
<li><b>Combine</b> Make the additions to get \(C\)</li>
</ul>
</div>
<div id="outline-container-orgheadline25" class="outline-5">
<h5 id="orgheadline25"><span class="section-number-5">4.2.2.1</span> Pseudocode</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<p>
<b>REC-MAT-MULT</b> \((A,B,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java">let C <span style="color: #b58900;">be</span> <span style="color: #268bd2;">a</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">n</span> x n matrix
<span style="color: #859900; font-weight: bold;">if</span> n == <span style="color: #268bd2; font-weight: bold;">1</span>
  c11 = a11 * b11
<span style="color: #859900; font-weight: bold;">else</span> partition A,<span style="color: #268bd2;">B</span> and C into n/<span style="color: #268bd2; font-weight: bold;">2</span> x n/<span style="color: #268bd2; font-weight: bold;">2</span> submatrices
  c11 = REC-MAT-MULT<span style="color: #2aa198;">(</span>A11,B11,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span> + REC-MAT-MULT<span style="color: #2aa198;">(</span>A12,B21,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>
  c12 = REC-MAT-MULT<span style="color: #2aa198;">(</span>A11,B12,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span> + REC-MAT-MULT<span style="color: #2aa198;">(</span>A12,B22,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>
  c21 = REC-MAT-MULT<span style="color: #2aa198;">(</span>A21,B11,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span> + REC-MAT-MULT<span style="color: #2aa198;">(</span>A22,B21,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>
  c22 = REC-MAT-MULT<span style="color: #2aa198;">(</span>A21,B12,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span> + REC-MAT-MULT<span style="color: #2aa198;">(</span>A22,B22,n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">return</span> C
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-5">
<h5 id="orgheadline26"><span class="section-number-5">4.2.2.2</span> Analysis</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<p>
Let \(T(n)\) be the times to multiply two \(n \times n\) matrices.
</p>
<ul class="org-ul">
<li><b>Base case</b>: \(n=1\). Perform one scalar multiplication: \(\Theta(1)\)</li>
<li><b>Recursive case</b>: \(n>1\)
<ul class="org-ul">
<li>Dividing takes \(\Theta(1)\) time if careful and \(\Theta(n^2)\) if simply copying</li>
<li>Conquering makes 8 recursive calls, each multiplying \(n/2 \times n/2\)
    matrices : \(8T(n/2)\)</li>
<li>Combining takes time \(\Theta(n^2)\) time to add \(n/2 \times n/2\) matrices.</li>
</ul></li>
</ul>
<p>
Reccurence is :
</p>
\begin{align*}
T(n) &= \Theta(1) \text{  if $n=1$}\\
T(n) &= 8T(n/2)+\Theta(n^2) \text{  if $n>1$}
\end{align*}
<p>
So \(T(n) = \Theta(n^3)\) (from master method)
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-4">
<h4 id="orgheadline29"><span class="section-number-4">4.2.3</span> Strassen's algorithm</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li><b>Divide</b> eachf \(A,B,C\) into four \(n/2 \times n/2\) matrices: so that :</li>
</ul>

<p>
\(\begin{pmatrix}
C_{11} & C_{12}\\
C_{21} & C_{22}
\end{pmatrix} = \begin{pmatrix}
A_{11} & A_{12}\\
A_{21} & A_{22}
\end{pmatrix} \cdot \begin{pmatrix}
B_{11} & B_{12}\\
B_{21} & B_{22}
\end{pmatrix}\)  
</p>

<ul class="org-ul">
<li><b>Conquer</b> : calculate recusively 7 matrix multiplications, each of two \(n/2
  \times n/2\) matrices :</li>
</ul>
\begin{align*}
&M_1 := (A_{11}+A_{22})(B_{11}+B_{22}) &\ M_5 := (A_{11}+A_{12})B_{22}\\
&M_2 := (A_{21}+A_{22})B_{11} &\ M_6 := (A_{21}-A_{11})(B_{11}+B_{12})\\
&M_3 := A_{11}(B_{12}-B_{22}) &\ M_7 := (A_{12}-A_{22})(B_{21}+B_{22})\\
&M_4 := A_{11}(B_{21}-B_{11})
\end{align*}

<ul class="org-ul">
<li><b>Combine</b> Let</li>
</ul>
\begin{align*}
&C_{11} = M_1 + M_4 - M_5 + M_7 &\ C_{12} = M_3 + M_5 \\
&C_{21} = M_2 + M_4 &\ C_{22} = M_1 - M_2 + M_3 + M_6
\end{align*}
</div>
<div id="outline-container-orgheadline28" class="outline-5">
<h5 id="orgheadline28"><span class="section-number-5">4.2.3.1</span> Time analysis</h5>
<div class="outline-text-5" id="text-4-2-3-1">
<ul class="org-ul">
<li>Base case \(n = 1\) \(\Rightarrow\) it takes time \(\Theta(1)\)</li>
<li>Recursive case: \(n > 1\)
<ul class="org-ul">
<li>Dividing takes time \(\Theta(n^2)\)</li>
<li>Conquering makes 7 recursive calls, each multiplying \(n/2 \times n/2\)
    matrices \(\Rightarrow 7 T(n/2)\)</li>
<li>Combining takes time \(\Theta(n^2)\) time to add \(n/2 \times n/2\) matrices.</li>
</ul></li>
</ul>
<p>
Reccurence is
</p>
\begin{align*}
T(n) = \Theta(1) \text{ if $n=1$}\\
T(n) = 7T(n/2) + \Theta(n^2) \text{ if $n > 1$}
\end{align*}
<p>
Master method \(\Rightarrow T(n) = \Theta(n^{\log_2 7})\) 
</p>

<p>
Best we could hope for is \(\Theta(n^2)\) because we need to at least look at each
entry of the matrices.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline62" class="outline-2">
<h2 id="orgheadline62"><span class="section-number-2">5</span> Week 5</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">5.1</span> Heap</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Heap \(A\) ( <span class="underline">not</span> garbage-collected storage) is a nearly complete binary trees
</p>
<ul class="org-ul">
<li>height \(\lceil \log_2(n)\rceil\)</li>
<li>Atmost one node has one child</li>
</ul>

<p>
(Max)-Heap property: key of \(i\) 's children is <span class="underline">smaller or equal</span> to \(i\) 's key
</p>

<p>
(Min)-Heap property: key of \(i\) 's children is <span class="underline">greater or equal</span> to \(i\) 's key
</p>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">5.1.1</span> Root :</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>Max-Heap \(\Rightarrow\) maximum element is the root</li>
<li>Min-heap \(\Rightarrow\) minimum elememnt is the root</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">5.1.2</span> Height :</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Height of node = # of edges on a longest simple path from the node down to a leaf
</p>

<p>
Height of heap = height of root = \(\Theta (\log n)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34"><span class="section-number-4">5.1.3</span> Storage :</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
Use that tree is almost complete to store it in array
<img src="images/al_ch5_01.png" alt="al_ch5_01.png" />
</p>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-4">
<h4 id="orgheadline37"><span class="section-number-4">5.1.4</span> Operations</h4>
<div class="outline-text-4" id="text-5-1-4">
</div><div id="outline-container-orgheadline35" class="outline-5">
<h5 id="orgheadline35"><span class="section-number-5">5.1.4.1</span> MAX-HEAPIFY</h5>
<div class="outline-text-5" id="text-5-1-4-1">
<p>
MAX-HEAPIFY : given an \(i\) such that the subtrees of \(i\) are heaps, it ensures
that the subtree rooted at \(i\) is a heap satisfying the heap property.
</p>

<p>
<b>Algorithm</b> :
</p>
<ul class="org-ul">
<li>Compare \(A[i],A[Left(i)],A[Right(i)]\)</li>
<li>If necessary, swap \(A[i]\) with the largest of the two children to preserve
heap property</li>
<li>Continue this process of comparing and swapping down the heap, until subtree
rooted at \(i\) is max-heap</li>
</ul>
<p>
<b>MAX-HEAPIFY</b> \((A,i,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java">l = Left<span style="color: #2aa198;">(</span>i<span style="color: #2aa198;">)</span>
r = Right<span style="color: #2aa198;">(</span>i<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> l &lt;= n and A<span style="color: #2aa198;">[</span>l<span style="color: #2aa198;">]</span> &gt; A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
  largest = l
<span style="color: #859900; font-weight: bold;">else</span> largest = i
<span style="color: #859900; font-weight: bold;">if</span> r &lt;= and A<span style="color: #2aa198;">[</span>r<span style="color: #2aa198;">]</span> &gt; A<span style="color: #2aa198;">[</span>largest<span style="color: #2aa198;">]</span>
  largest = r
<span style="color: #859900; font-weight: bold;">if</span> largest != i
  exchange A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> with A<span style="color: #2aa198;">[</span>largest<span style="color: #2aa198;">]</span>
  MAX-HEAPIFY<span style="color: #2aa198;">(</span>A,largest,n<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
<b>Running time</b> : \(\Theta(\) height of \(i)=O(\log n)\)
</p>

<p>
<b>Space</b> : \(\Theta(n)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline36" class="outline-5">
<h5 id="orgheadline36"><span class="section-number-5">5.1.4.2</span> Building a heaps</h5>
<div class="outline-text-5" id="text-5-1-4-2">
<p>
Given unordered array \(A\) of length \(n\), BUILD-MAX-HEAP(A,n)
</p>

<p>
<b>BUILD-MAX-HEAP</b> \((A,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">for</span> i = floor<span style="color: #2aa198;">(</span>n/<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">)</span> downto <span style="color: #268bd2; font-weight: bold;">1</span>
  MAX-HEAPIFY<span style="color: #2aa198;">(</span>A,i,n<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
<b>Analysis</b>
</p>

<p>
Worst case :
</p>
<ul class="org-ul">
<li>Simple bound : \(O(n)\) calls to MAX-HEAPIFY, each of wich takes \(O(\log n)\)
  time \(\Rightarrow O(n \log n)\) in total</li>
<li>Tighter anaysis : Time to run MAX-HEAPIFY is linear in the height of the node
it's run on. Hence the time bounded by :</li>
</ul>

<p>
\(\sum\limits_{h=0}^{\log n}
  \lbrace \text{# nodes of height } h \rbrace O(h) = O(n \sum\limits_{h=0}^{\log
  n} \frac{h}{2^h})\)
</p>

<p>
which is \(O(n)\) since \(\sum\limits_{h=0}^{\infty} \frac{h}{2^h} =
\frac{1/2}{(1-1/2)^2} = 2\)
</p>

<p>
<b>Correctness</b>
</p>

<p>
<span class="underline">Loop invariant</span> : At start of every iteration of <b>for</b> loop, each node
\(i+1,i+2,...,n\) is root of max-heap
</p>

<p>
<span class="underline">Maintenance</span> :
</p>
<ul class="org-ul">
<li>Children of node \(i\) are indexed higher than \(i\), so by the loop invariant,
they are both roots of max-heaps</li>
<li>Therefore, MAX-HEAPIFY makes node \(i\) a max-heap root (so \(i,i+1,...,n\) are
all roots of max-heaps)</li>
<li>Hence, the invariant stays true when decredementing \(i\) at the beggining of
the next iteration</li>
</ul>

<p>
<span class="underline">Termination</span>:
</p>
<ul class="org-ul">
<li>When \(i = 0\), the loop terminates</li>
<li>By the loop invariant, each node, notably node 1, is the root of a max-heap</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-3">
<h3 id="orgheadline41"><span class="section-number-3">5.2</span> Heapsort</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>Builds a max-heap from the array</li>
<li>Starting with the root (the maximum element), the algorithm places the maximum
element into the correct place in the array by swapping it with the element in
the last position in the array</li>
<li>"Discard" this last node (knowing that it is in its correct place) by
decreasing the heap size, and calling MAX-HEAPIFY on the new (possibly
incorrect-placed) root</li>
<li>Repeat this "discarding" process until only one node (the smallest element)
remains, and therefore is in the correct place in the array</li>
</ul>
</div>
<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">5.2.1</span> Pseudocode :</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
<b>HEAPSORT</b> \((A,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java">BUILD-MAX-HEAP<span style="color: #2aa198;">(</span>A,n<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">for</span> i = n downto <span style="color: #268bd2; font-weight: bold;">2</span>
  exchange A<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> with A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
  MAX-HEAPIFY<span style="color: #2aa198;">(</span>A,<span style="color: #268bd2; font-weight: bold;">1</span>,i-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline40" class="outline-4">
<h4 id="orgheadline40"><span class="section-number-4">5.2.2</span> Analysis</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li>BUILD-MAX-HEAP : \(O(n)\)</li>
<li><b>for</b> loop: \(n-1\) times</li>
<li>exchange elements: \(O(1)\)</li>
<li>MAX-HEAPIFY: \(O(\lg n)\)</li>
</ul>

<p>
<b>Total time</b> : \(O(n \lg n)\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-3">
<h3 id="orgheadline46"><span class="section-number-3">5.3</span> Priorty queue</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Maintains a dynamic set \(S\) of elements</li>
<li>Each set element has a <b>key</b> - an associated value that regulates its importance</li>
<li>Operations :
<ul class="org-ul">
<li>INSERT(S,x): inserts element \(x\) into \(S\)</li>
<li>MAXIMUM(S) : returns element of \(S\) with largest key</li>
<li>EXTRACT-MAX(S): removes and returns element of \(S\) with largest key</li>
<li>INCREASED-KEY(S,x,K): increases value of element \(x\) 's key to \(k\); assume \(k
    \le x\) 's current key value.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgheadline45" class="outline-4">
<h4 id="orgheadline45"><span class="section-number-4">5.3.1</span> Operations</h4>
<div class="outline-text-4" id="text-5-3-1">
</div><div id="outline-container-orgheadline42" class="outline-5">
<h5 id="orgheadline42"><span class="section-number-5">5.3.1.1</span> HEAP-MAXIMUM</h5>
<div class="outline-text-5" id="text-5-3-1-1">
<p>
Symply return the root in time \(\Theta(1)\)
</p>

<p>
<b>HEAP-MAXIMUM</b> \((A)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Return</span> <span style="color: #268bd2;">A</span><span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline43" class="outline-5">
<h5 id="orgheadline43"><span class="section-number-5">5.3.1.2</span> HEAP-EXTRACT-MAX(A,n)</h5>
<div class="outline-text-5" id="text-5-3-1-2">
<ol class="org-ol">
<li>Make sure heap is not empty</li>
<li>Make a copy of the maximum element (the root)</li>
<li>Make the last node in the tree the new root</li>
<li>Re-heapify the heap, with one fewer node</li>
</ol>

<p>
<span class="underline">Analysis</span> : Constant-time assignments plus time for MAX-HEAPIFY
</p>

<p>
So \(O(\lg n)\)
</p>

<p>
<b>HEAP-EXTRACT-MAX</b> \((A,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> n &lt; <span style="color: #268bd2; font-weight: bold;">1</span>
  error <span style="color: #2aa198;">"heap underflow"</span>
max = A<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
A<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> = A<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
n = n - <span style="color: #268bd2; font-weight: bold;">1</span>
MAX-HEAPIFY<span style="color: #2aa198;">(</span>A,<span style="color: #268bd2; font-weight: bold;">1</span>,n<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">return</span> max
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline44" class="outline-5">
<h5 id="orgheadline44"><span class="section-number-5">5.3.1.3</span> HEAP-INCREASE-KEY(A,i,key)</h5>
<div class="outline-text-5" id="text-5-3-1-3">
<p>
Given a heap \(A\), index \(i\), and a new value \(key\)
</p>
<ol class="org-ol">
<li>Make sure \(key >= A[i]\)</li>
<li>Update \(A[i]\) 's value to \(key\)</li>
<li>Traverse the tree upward comparing new key to the parent and swapping keys if
necessary, until the new key is smaller than the parent's keys</li>
</ol>

<p>
<span class="underline">Analysis</span> : Upward path frome node \(i\) has length \(O(\lg n)\) in an \(n\) -element
heap.
</p>

<p>
So \(O(\lg n)\)
</p>

<p>
<b>HEAP-INCREASE-KEY</b> \((A,i,key)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">key</span> <span style="color: #2aa198;">&lt;</span> <span style="color: #b58900;">A</span><span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>
  error <span style="color: #2aa198;">"new key is smaller than current key"</span>
A<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> = key
<span style="color: #859900; font-weight: bold;">while</span> i <span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2; font-weight: bold;">1</span> and A<span style="color: #2aa198;">[</span>Parent<span style="color: #b58900;">(</span>i<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span> &lt; A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
  exchange A<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> with A<span style="color: #2aa198;">[</span>Parent<span style="color: #b58900;">(</span>i<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
  i = Parent<span style="color: #2aa198;">(</span>i<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-3">
<h3 id="orgheadline49"><span class="section-number-3">5.4</span> Stacks</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Last in, first out.
</p>
<ul class="org-ul">
<li>Insert operation called PUSH(\(S,x\))</li>
<li>Delete operation called POP(\(S\))</li>
</ul>
</div>
<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47"><span class="section-number-4">5.4.1</span> Implementation</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Implementation using arrays: \(S\) consists of elements \(S[1,...,S.top]\)
</p>
<ul class="org-ul">
<li>\(S[1]\) element at the bottom</li>
<li>\(S[S.top]\) element at the top</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">5.4.2</span> Operations</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
<b>STACK-EMPTY</b> \((S)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> S.top = <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
</pre>
</div>

<p>
<b>PUSH</b> \((S,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">S.top = S.top + <span style="color: #268bd2; font-weight: bold;">1</span>
S<span style="color: #2aa198;">[</span>S.top<span style="color: #2aa198;">]</span> = x
</pre>
</div>

<p>
<b>POP</b> \((S)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> STACK-EMPTY<span style="color: #2aa198;">(</span>S<span style="color: #2aa198;">)</span>
  error <span style="color: #2aa198;">"underflow"</span>
<span style="color: #859900; font-weight: bold;">else</span>
  S.top = S.top -<span style="color: #268bd2; font-weight: bold;">1</span>
  <span style="color: #859900; font-weight: bold;">return</span> S<span style="color: #2aa198;">[</span>S.top+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
</pre>
</div>

<p>
All these operations are \(O(1)\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline52" class="outline-3">
<h3 id="orgheadline52"><span class="section-number-3">5.5</span> Queue</h3>
<div class="outline-text-3" id="text-5-5">
<p>
First-in, first-outputs
</p>
<ul class="org-ul">
<li>Insert operation called ENQUEUE(\(Q,x)\)</li>
<li>Delete operation called DEQUEUE\((Q)\)</li>
</ul>
</div>
<div id="outline-container-orgheadline50" class="outline-4">
<h4 id="orgheadline50"><span class="section-number-4">5.5.1</span> Implementation</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Implementation using arrays: \(Q\) consists of elements \(S[Q.head,...,Q.tail-1]\)
</p>
<ul class="org-ul">
<li>\(Q.head\) points at the first elements</li>
<li>\(Q.tail\) points at the next location where a newly arrived alement wille be placed</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51"><span class="section-number-4">5.5.2</span> Operations</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
<b>ENQUEUE</b> \((Q,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">Q<span style="color: #2aa198;">[</span>Q.tail<span style="color: #2aa198;">]</span> = x
<span style="color: #859900; font-weight: bold;">if</span> Q.tail == Q.length
  Q.tail = <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">else</span> Q.tail = Q.tail + <span style="color: #268bd2; font-weight: bold;">1</span>
</pre>
</div>

<p>
<b>DEQUEUE</b> \((Q,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">x = Q<span style="color: #2aa198;">[</span>Q.head<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">if</span> Q.head == Q.length
  Q.head = <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">else</span> Q.head = Q.head + <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">return</span> x
</pre>
</div>

<p>
All these operations are \(O(1)\)
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline55" class="outline-3">
<h3 id="orgheadline55"><span class="section-number-3">5.6</span> Stacks and queues</h3>
<div class="outline-text-3" id="text-5-6">
</div><div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">5.6.1</span> Pros</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>Very efficent</li>
<li>Natural operations</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54"><span class="section-number-4">5.6.2</span> Cons</h4>
<div class="outline-text-4" id="text-5-6-2">
<ul class="org-ul">
<li>Limited support: for example, no search</li>
<li>Implementations using arrays have a fixed capacity</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61"><span class="section-number-3">5.7</span> Linked list</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Objects are arranged in a linear order : not indexes in array, but pointer to
next object in each object.
</p>

<p>
A list can be :
</p>
<ul class="org-ul">
<li>Single linked or double linked</li>
<li>Sorted or unsorted</li>
<li>etc.</li>
</ul>

<p>
Example : An element in a double linked list :
</p>
<ul class="org-ul">
<li>x.key (key value)</li>
<li>x.prev (point to previous element)</li>
<li>x.next (points to next element)</li>
</ul>
</div>
<div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56"><span class="section-number-4">5.7.1</span> Searching in a linked list</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
Given \(k\) return pointer to first element with key \(k\)
</p>

<p>
<b>LIST-SEARCH</b> \((L,k)\)
</p>
<div class="org-src-container">

<pre class="src src-java">x = L.head
<span style="color: #859900; font-weight: bold;">while</span> x != nil and x.key != k
  x = x.next
<span style="color: #859900; font-weight: bold;">return</span> x
</pre>
</div>

<p>
Running time : \(O(n)\)
</p>

<p>
If no element with key \(k\) ? Returns <i>nil</i>
</p>
</div>
</div>

<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">5.7.2</span> Inserting into a linked list</h4>
<div class="outline-text-4" id="text-5-7-2">
<p>
Insert a new element \(x\)
</p>

<p>
<b>LIST-INSERT</b> \((L,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">x.next = L.head
<span style="color: #859900; font-weight: bold;">if</span> L.head != nil
  L.head.prev = x
L.head = x
x.prev = NIL
</pre>
</div>

<p>
Running time : \(O(1)\)
</p>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58"><span class="section-number-4">5.7.3</span> Deleting from a linked list</h4>
<div class="outline-text-4" id="text-5-7-3">
<p>
Given a pointer to an element \(x\) removes it from \(L\)
</p>

<p>
<b>LIST-DELETE</b> \((L,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x.prev != nil
  x.prev.next = x.next
<span style="color: #859900; font-weight: bold;">else</span> L.head = x.next
<span style="color: #859900; font-weight: bold;">if</span> x.next != nil
  x.next.prev = x.prev
</pre>
</div>

<p>
Running time : \(O(1)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline59" class="outline-4">
<h4 id="orgheadline59"><span class="section-number-4">5.7.4</span> <span class="todo TODO">TODO</span> Using Sentinels</h4>
<div class="outline-text-4" id="text-5-7-4">
<p>
<b>Add image for clarity</b>
</p>

<p>
We add a "sentinel" called L.nil which
</p>
<ul class="org-ul">
<li>Points to itself for prev and next if list is empty</li>
<li>Next points to first element of list (head), prev points to last element of the list
and last element of the list points to it</li>
</ul>

<p>
Then we can symplify delete and insert by :
</p>

<p>
<b>LIST-DELETE</b> \((L,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">x.prev.next = x.next
x.next.prev = x.prev
</pre>
</div>

<p>
<b>LIST-INSERT</b> \((L,x)\)
</p>
<div class="org-src-container">

<pre class="src src-java">x.next = L.nil.next
L.nil.next.prev = x
L.nil.next = x
x.prev = L.nil
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60"><span class="section-number-4">5.7.5</span> Summary</h4>
<div class="outline-text-4" id="text-5-7-5">
<ul class="org-ul">
<li>Dynamic data structure without predefined capacity</li>
<li>Insertion : \(O(1)\)</li>
<li>Deletion : \(O(1)\) (if double linked)</li>
<li>Search : \(O(n)\)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline95" class="outline-2">
<h2 id="orgheadline95"><span class="section-number-2">6</span> Week 6</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgheadline72" class="outline-3">
<h3 id="orgheadline72"><span class="section-number-3">6.1</span> Binary Search trees</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Encodes a strategy whatever number we look for.
</p>

<p>
Key property:
</p>
<ul class="org-ul">
<li>if \(y\) is in the left subtree of \(x\) then \(y.key < x.key\)</li>
<li>if \(y\) is in the right subtree of \(x\) then \(y.key \ge x.key\)</li>
</ul>

<p>
Height (\(h\)) is the number of edges in longest path from root to leaf.
</p>

<p>
Basic operations take time proportional to height: \(O(h)\)
</p>

<p>
Each element \(x\) has :
</p>
<ul class="org-ul">
<li>\(x.left\) : pointer to left child</li>
<li>\(x.right\) : pointer to right child</li>
<li>\(x.p\) : pointer to parent</li>
<li>\(x.key\) : key</li>
</ul>
</div>
<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63"><span class="section-number-4">6.1.1</span> Searching</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
<b>TREE-SEARCH</b> \((x,k)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x == NIL or k == key<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">return</span> x
<span style="color: #859900; font-weight: bold;">if</span> k &lt; x.<span style="color: #b58900;">key</span>
  <span style="color: #859900; font-weight: bold;">return</span> TREE-SEARCH<span style="color: #2aa198;">(</span>x.left,k<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> TREE-SEARCH<span style="color: #2aa198;">(</span>x.right,k<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
Running time : \(O(h)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64"><span class="section-number-4">6.1.2</span> Min and Max</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
By key property :
</p>
<ul class="org-ul">
<li>Minimum is located in leftmost node</li>
<li>Maximum is located in rightmost node</li>
</ul>

<p>
<b>TREE-MINIMUM</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">while</span> x.left != NIL
  x = x.left
<span style="color: #859900; font-weight: bold;">return</span> x
</pre>
</div>

<p>
<b>TREE-MAXIMUM</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">while</span> x.right != NIL
  x = x.right
<span style="color: #859900; font-weight: bold;">return</span> x
</pre>
</div>

<p>
Running time : \(O(h)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">6.1.3</span> Sucessor and Predecessor</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Sucessor of a node \(x\) is the node \(y\) sutch that \(y.key\) is the
</p>

<p>
"smallest key" &gt; \(x.key\)
</p>

<p>
Two case :
</p>
<ul class="org-ul">
<li>\(x\) has a non-empty right subtree &rarr; \(x\) 's sucessor is the minimum
in the right subtree</li>
<li>\(x\) has an empty right subtree &rarr; As long as we go to the left up the
tree we're visiting smaller keys. \(x\) 's sucessor is \(y\) is the  node that \(x\)
is the predecessor of.</li>
</ul>

<p>
<b>TREE-SUCESSOR</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x.right != NIL
  <span style="color: #859900; font-weight: bold;">return</span> TREE-MINIMUM<span style="color: #2aa198;">(</span>x.right<span style="color: #2aa198;">)</span>
y = x.p
<span style="color: #859900; font-weight: bold;">while</span> y != NIL and x == y.right
  x = y
  y = y.p
<span style="color: #859900; font-weight: bold;">return</span> y
</pre>
</div>

<p>
Running time : \(O(h)\)
</p>

<p>
Predecessor is symmetric !
</p>
</div>
</div>

<div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68"><span class="section-number-4">6.1.4</span> Printing</h4>
<div class="outline-text-4" id="text-6-1-4">
</div><div id="outline-container-orgheadline66" class="outline-5">
<h5 id="orgheadline66"><span class="section-number-5">6.1.4.1</span> Inorder</h5>
<div class="outline-text-5" id="text-6-1-4-1">
<ul class="org-ul">
<li>Print left subtree recursively</li>
<li>Print root</li>
<li>Print right subtree recursively</li>
</ul>

<p>
<b>INORDER-TREE-WALK</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x != NIL
  INORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.left<span style="color: #2aa198;">)</span>
  print key<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span>
  INORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.right<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
Running time : \(\theta(n)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline67" class="outline-5">
<h5 id="orgheadline67"><span class="section-number-5">6.1.4.2</span> Preorder and Postorder</h5>
<div class="outline-text-5" id="text-6-1-4-2">
<p>
<b>PREORDER-TREE-WALK</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x != NIL
  print key<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span>
  PREORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.left<span style="color: #2aa198;">)</span>
  PREORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.right<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
<b>POSTORDER-TREE-WALK</b> \((x)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> x != NIL
  POSTORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.left<span style="color: #2aa198;">)</span>
  POSTORDER-TREE-WALK<span style="color: #2aa198;">(</span>x.right<span style="color: #2aa198;">)</span>
  print key<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline71" class="outline-4">
<h4 id="orgheadline71"><span class="section-number-4">6.1.5</span> Modifying</h4>
<div class="outline-text-4" id="text-6-1-5">
</div><div id="outline-container-orgheadline69" class="outline-5">
<h5 id="orgheadline69"><span class="section-number-5">6.1.5.1</span> Inserting</h5>
<div class="outline-text-5" id="text-6-1-5-1">
<ul class="org-ul">
<li>Search for \(z.key\)</li>
<li>When arrived at \(nil\) insert \(z\) at that position</li>
</ul>

<p>
<b>TREE-INSERT</b> \((T,z)\)
</p>
<div class="org-src-container">

<pre class="src src-java">y = NIL
x = T.root
<span style="color: #859900; font-weight: bold;">while</span> x != NIL
  y = x
  <span style="color: #859900; font-weight: bold;">if</span> z.key &lt; x.<span style="color: #b58900;">key</span>
    x = x.left
  <span style="color: #859900; font-weight: bold;">else</span> x = x.right
z.p = y
<span style="color: #859900; font-weight: bold;">if</span> y == NIL
  T.root = z <span style="color: #586e75;">// </span><span style="color: #586e75;">tree T was empty</span>
elseif z.key &lt; y.<span style="color: #b58900;">key</span>
  y.left = z
<span style="color: #859900; font-weight: bold;">else</span> y.right = z
</pre>
</div>

<p>
Running time : \(O(h)\)
</p>
</div>
</div>

<div id="outline-container-orgheadline70" class="outline-5">
<h5 id="orgheadline70"><span class="section-number-5">6.1.5.2</span> Deleting</h5>
<div class="outline-text-5" id="text-6-1-5-2">
<p>
3 cases :
</p>
<ul class="org-ul">
<li>If \(z\) has no children, remove it</li>
<li>if \(z\) has one child, then make that child takes \(z\) 's position in the tree</li>
<li>if \(z\) has two children, then find its sucessor \(y\) and replace \(z\) by \(y\)</li>
</ul>

<p>
We first need to define a helper function which replace subtree rooted at \(u\) with
that rooted at \(v\)
</p>

<p>
<b>TRANSPLANT</b> \((T,u,v)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> u.p == NIL
  T.root = v
elseif u == u.p.left
  u.p.left = v
<span style="color: #859900; font-weight: bold;">else</span> u.p.right = v
<span style="color: #859900; font-weight: bold;">if</span> v != NIL
  v.p = u.p
</pre>
</div>

<p>
Then the actual deletion algorithm :
</p>

<p>
<b>TREE-DELETE</b> \((T,z)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> z.left == NIL
  TRANSPLANT<span style="color: #2aa198;">(</span>T,z,z.right<span style="color: #2aa198;">)</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">z has no left child</span>
elseif z.right == NIL
  TRANSPLANT<span style="color: #2aa198;">(</span>T,z,z.left<span style="color: #2aa198;">)</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">z has just a left child</span>
<span style="color: #859900; font-weight: bold;">else</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">z has two children</span>
  y = TREE-MINIMUM<span style="color: #2aa198;">(</span>z.right<span style="color: #2aa198;">)</span> <span style="color: #586e75;">// </span><span style="color: #586e75;">y is z's sucessor</span>
  <span style="color: #859900; font-weight: bold;">if</span> y.p != z
    <span style="color: #586e75;">// </span><span style="color: #586e75;">y lies within z's right subtree but is not the root of this</span>
    TRANSPLANT<span style="color: #2aa198;">(</span>T,y,y.right<span style="color: #2aa198;">)</span>
    y.right = z.right
    y.right.p = y
  <span style="color: #586e75;">// </span><span style="color: #586e75;">Replace z by y</span>
  TRANSPLANT<span style="color: #2aa198;">(</span>T,z,y<span style="color: #2aa198;">)</span>
  y.left = z.left
  y.left.p = y
</pre>
</div>

<p>
Running time : \(O(h)\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline74" class="outline-3">
<h3 id="orgheadline74"><span class="section-number-3">6.2</span> Dynamic programming</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Main idea :
</p>
<ul class="org-ul">
<li>Remember calculations already made</li>
<li>Saves enormous amounts of computation</li>
</ul>
</div>
<div id="outline-container-orgheadline73" class="outline-4">
<h4 id="orgheadline73"><span class="section-number-4">6.2.1</span> Key element in designing a DP-algorithm</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
<span class="underline">Optimal substructure :</span>
</p>
<ul class="org-ul">
<li>Show that a solution to a problem consists of making a choice, which leaves
one or several subproblems to solve and the optimal solution solves the
subproblems optimally &rArr; allows us to write a recursion</li>
</ul>

<p>
<span class="underline">Overlapping subproblems :</span>
</p>
<ul class="org-ul">
<li>A naive recursive algorithm may revisit the same (sub)problem over and over.</li>
<li>Top-down with memoization : Solve recursively but store each result in a table
(only solves subproblems really required to find solution)</li>
<li>Bottom-up Sort the subproblems and solve the smaller ones first; that way,
when solving a subproblem, have already solved the smaller subproblems we need
(can be better in term of memory)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline77" class="outline-3">
<h3 id="orgheadline77"><span class="section-number-3">6.3</span> Fibonacci numbers</h3>
<div class="outline-text-3" id="text-6-3">
<p>
basic resursive function : same calculations again and again &rArr; exponential time !
</p>

<p>
Solution ? Remember what we have down :
</p>

<p>
Two ways:
</p>
<ul class="org-ul">
<li>Top-down with memoization
<ul class="org-ul">
<li>Solve recursively but store each result in a table</li>
<li>Memoizing is remembering what we have computed previously</li>
</ul></li>
<li>Bottom-up
<ul class="org-ul">
<li>Sort the subproblems and solve the smaller ones first</li>
<li>That way, when solving a subproblem, have already solved the smaller subproblems we need</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgheadline75" class="outline-4">
<h4 id="orgheadline75"><span class="section-number-4">6.3.1</span> Memoization</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
<b>MEMOIZED-FIB</b> \((n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Let</span> <span style="color: #268bd2;">r</span> = <span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>...n<span style="color: #2aa198;">]</span> be a <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">array</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">0</span> to n
  r<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = - infinity
<span style="color: #859900; font-weight: bold;">return</span> MEMOIZED-FIB-AUX<span style="color: #2aa198;">(</span>n,r<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
<b>MEMOIZED-FIB-AUX</b> \((n,r)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span> &gt;= <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">return</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">if</span> n = <span style="color: #268bd2; font-weight: bold;">0</span> or n = <span style="color: #268bd2; font-weight: bold;">1</span>
  ans = <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">else</span>
  ans = MEMOIZED-FIB-AUX<span style="color: #2aa198;">(</span>n-<span style="color: #268bd2; font-weight: bold;">1</span>,r<span style="color: #2aa198;">)</span>+MEMOIZED-FIB-AUX<span style="color: #2aa198;">(</span>n-<span style="color: #268bd2; font-weight: bold;">2</span>,r<span style="color: #2aa198;">)</span>
r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span> = ans
<span style="color: #859900; font-weight: bold;">return</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
</pre>
</div>

<p>
Time analysis :
</p>
<ul class="org-ul">
<li>Steps 1-3 in MEMOIZED-FIB takes times \(\Theta(n)\)</li>
<li>Each call to MEMOIZED-FIB-AUX takes \(\Theta(1)\)</li>
<li>Number of calls to MEMOIZED-FIB-AUX is \(\Theta(n)\)</li>
<li>Total time is thus \(\Theta(n)\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline76" class="outline-4">
<h4 id="orgheadline76"><span class="section-number-4">6.3.2</span> Bottom-updates</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
<b>BOTTOM-UP-FIB</b> \((n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Let</span> <span style="color: #268bd2;">r</span> = <span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..n<span style="color: #2aa198;">]</span> be a <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">aray</span>
r<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>
r<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">2</span> to n
  r<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = r<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>+r<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">return</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline86" class="outline-3">
<h3 id="orgheadline86"><span class="section-number-3">6.4</span> Rod cutting</h3>
<div class="outline-text-3" id="text-6-4">
<p>
<span class="underline">Instance</span> :
</p>
<ul class="org-ul">
<li>A length \(n\) of a metal rod</li>
<li>A table of prices \(p_i\) for rods of lengths \(i=1,...n\)</li>
</ul>

<p>
<span class="underline">Objective</span> : Decide how to cut the rod into pieces and maximize the price
</p>
</div>

<div id="outline-container-orgheadline78" class="outline-4">
<h4 id="orgheadline78"><span class="section-number-4">6.4.1</span> Size of the problem</h4>
<div class="outline-text-4" id="text-6-4-1">
<ul class="org-ul">
<li>There are 2<sup>n-1</sup> possible solutions - either cut or do not cut after every length unit</li>
<li>Need structure for an efficient algorithm</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline79" class="outline-4">
<h4 id="orgheadline79"><span class="section-number-4">6.4.2</span> Structural theorem</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
If
</p>
<ul class="org-ul">
<li>the leftmost cut in an optimal solution is after \(i\) units</li>
<li>an optimal way to cut a solution of size \(n-i\) is into rods of sizes: \(s_1,s_2,...,s_k\)</li>
</ul>
<p>
Then, an optimal way to cut our rods is into rods of size: \(i,s_1,s_2,...,s_k\)
</p>

<p>
<span class="underline">Proof</span>
</p>

<p>
Feasability : Since \(s_1,s_2,...,s_k\) is a feasible solution for  an instance of
size \(n-i\):
</p>

<p>
\(\sum\limits_{j=1}^k s_j = n - i\)
</p>

<p>
Hence, \(i + \sum\limits_{j=1}^k s_j = n\)
</p>

<p>
Optimality: Let \(i,o_1,o_2,...,o_l\) be an optimal solution - exists by
assumption. Recall that \(s_1,s_2,...,s_k\) is an optimal way to cut a rod of size
\(n-1\), thus
</p>

<p>
\(\sum\limits_{j=1}^k p_{s_j} \ge \sum\limits_{j=1}^l p_{o_j}\)
</p>

<p>
Hence, \(p_i + \sum\limits_{j=1}^k p_{s_j} \ge p_i + \sum\limits_{j=1}^l p_{o_j}\)
</p>
</div>
</div>

<div id="outline-container-orgheadline80" class="outline-4">
<h4 id="orgheadline80"><span class="section-number-4">6.4.3</span> First algorithm</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
if we let \(r(n)\) be the optimal revenu from a rod of length \(n\), then, by 
the strucural theorem, we can express \(r(n)\) recursively as follows
</p>

<p>
\(r(n) = 0\) if \(n = 0\)
</p>

<p>
\(r(n) = \text{max}_{1\le i \le n}\lbrace p_i + r(n-i)\rbrace\) otherwise \(n \ge 1\)
</p>

<p>
<b>CUT-ROD</b> \((p,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> n == <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">0</span>
q = -infinity
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  q = max<span style="color: #2aa198;">(</span>q,p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>+ CUT-ROD<span style="color: #b58900;">(</span>p,n-i<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">return</span> q
</pre>
</div>

<p>
Procedure is extremly inefficient, exponential
</p>
</div>
</div>

<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">6.4.4</span> Top-down algorithm</h4>
<div class="outline-text-4" id="text-6-4-4">
<ul class="org-ul">
<li>Keep the recurive structure of the pseudocode</li>
<li>Memoize (store) the result of every recursive call</li>
<li>At each recursively call, try to avoid work using memoized results</li>
</ul>

<p>
<b>MEMOIZED-CUT-ROD</b> \((p,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">let</span> <span style="color: #268bd2;">r</span><span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..n<span style="color: #2aa198;">]</span> be a <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">array</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">0</span> to n
  r<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = -infinity
<span style="color: #859900; font-weight: bold;">return</span> MEMOIZED-CUT-ROD-AUX<span style="color: #2aa198;">(</span>p,n,r<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
<b>MEMOIZED-CUT-ROD-AUX</b> \((p,n,r)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span> &gt;= <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">return</span> r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">if</span> n == <span style="color: #268bd2; font-weight: bold;">0</span>
  q == <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">else</span> q = -infinity
  <span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n
    q = max<span style="color: #2aa198;">(</span>q,p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>+MEMOIZED-CUT-ROD-AUX<span style="color: #b58900;">(</span>p,n-i,r<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
r<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span> = q
<span style="color: #859900; font-weight: bold;">return</span> q
</pre>
</div>

<ul class="org-ul">
<li>Initialization takes \(O(n)\) time</li>
<li>Processing each sub-problems takes linear time in the number of sub-problems
it evokes</li>
<li>The time complexity is proportional to the numbers of nodes and edges in the
subproblem graph</li>
</ul>

<p>
Time complexity : \(O(n^2)\)
</p>
</div>
</div>

<div id="outline-container-orgheadline82" class="outline-4">
<h4 id="orgheadline82"><span class="section-number-4">6.4.5</span> Bottom-up</h4>
<div class="outline-text-4" id="text-6-4-5">
<ul class="org-ul">
<li>Sort the sub-problems by size</li>
<li>Solve the smaller ones first</li>
<li>When reaching sub-problem, the smaller ones are already solved</li>
</ul>

<p>
<b>BOTTOM-UP-CUT-ROD</b> \((p,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">let</span> <span style="color: #268bd2;">r</span><span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..n<span style="color: #2aa198;">]</span> be a <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">array</span>
r<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  q = - infinity
  <span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to j
    q = max<span style="color: #2aa198;">(</span>q,p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>+r<span style="color: #b58900;">[</span>j-i<span style="color: #b58900;">]</span>
  r<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = q
<span style="color: #859900; font-weight: bold;">return</span> r<span style="color: #b58900;">[</span>n<span style="color: #b58900;">]</span>
</pre>
</div>

<p>
Time complexity : \(O(n^2)\)
</p>
</div>
</div>
<div id="outline-container-orgheadline83" class="outline-4">
<h4 id="orgheadline83"><span class="section-number-4">6.4.6</span> Analysis</h4>
<div class="outline-text-4" id="text-6-4-6">
<ul class="org-ul">
<li>Choice: where to make the leftmost cut</li>
<li>Optimal substructure: to obtain an optimal solution, we need to cut the
remaining piece in an optimal way</li>
</ul>

<p>
Hence, if we let r (n) be the optimal revenue from a rod of length n, we
can express \(r(n)\) recursively as follows
</p>

<p>
\(r(n) = 0\) if \(n = 0\)
</p>

<p>
\(r(n) = max_{1\le i \le n} \lbrace p_i + r(n-i)\rbrace\) otherwise if \(n \ge 1\)
</p>

<ul class="org-ul">
<li>Overlapping subproblems: Solve recurrence using top-down with memoization or
bottom-up which yields an algorithm that runs in time \(\Theta(n^2)\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline84" class="outline-4">
<h4 id="orgheadline84"><span class="section-number-4">6.4.7</span> Optimal solution</h4>
<div class="outline-text-4" id="text-6-4-7">
<ul class="org-ul">
<li>The above algorithms only return the optimal profit</li>
<li>Sometimes one needs also to find an optimal solution</li>
</ul>

<p>
<span class="underline">Approach</span>
</p>
<ul class="org-ul">
<li>Each cell of the memoization table corresponds to a decision: the location of
the left most cut</li>
<li>Store the decision corresponding to every cell in a separate table</li>
</ul>

<p>
<b>EXTENDED-BOTTOM-UP-CUT-ROD</b> \((p,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">let</span> <span style="color: #268bd2;">r</span><span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..n<span style="color: #2aa198;">]</span> and s<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..n<span style="color: #2aa198;">]</span> be <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">arrays</span>
r<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  q = - infinity
  <span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to j
    q = p<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> + r<span style="color: #2aa198;">[</span>j-i<span style="color: #2aa198;">]</span>
    s<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span> = i
  r<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span> = q
<span style="color: #859900; font-weight: bold;">return</span> r and s
</pre>
</div>

<ul class="org-ul">
<li>The table <b>s</b> stores the choices that lead to an optimal solution.</li>
<li>These decicisions can be extracted from the table</li>
</ul>

<p>
<b>PRINT-CUT-ROD-SOLUTION</b> \((p,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #2aa198;">(</span>r,s<span style="color: #2aa198;">)</span> = EXTENDED-BOTTOM-UP-CUT-ROD<span style="color: #2aa198;">(</span>p,n<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">while</span> n &gt; <span style="color: #268bd2; font-weight: bold;">0</span>
  print s<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
  n = n - s<span style="color: #2aa198;">[</span>n<span style="color: #2aa198;">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline85" class="outline-4">
<h4 id="orgheadline85"><span class="section-number-4">6.4.8</span> Summary</h4>
<div class="outline-text-4" id="text-6-4-8">
<ul class="org-ul">
<li>We had a recursive formulation for the optimal value for our problem</li>
</ul>
<p>
\(r(n) = 0\) if \(n = 0\)
</p>

<p>
\(r(n) = max_{1\le i \le n} \lbrace p_i + r(n-i)\rbrace\) otherwise if \(n \ge 1\)
</p>
<ul class="org-ul">
<li>Speed up the calculations by fillind in a table either "top-down with
memoization" or with "bottom-up"</li>
<li>Recovered an optimal solution using an additional table</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline94" class="outline-3">
<h3 id="orgheadline94"><span class="section-number-3">6.5</span> Matrix-chain multiplication</h3>
<div class="outline-text-3" id="text-6-5">
</div><div id="outline-container-orgheadline87" class="outline-4">
<h4 id="orgheadline87"><span class="section-number-4">6.5.1</span> Cost of matrix multiplication</h4>
<div class="outline-text-4" id="text-6-5-1">
<p>
\(A_{p,q} \times B_{q,r}\) = \(C_{p,r}\)
</p>

<ul class="org-ul">
<li>Each cell of \(C\) requires \(q\) scalar multiplication</li>
<li>In total : \(pqr\) scalar multiplication</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline88" class="outline-4">
<h4 id="orgheadline88"><span class="section-number-4">6.5.2</span> Definition</h4>
<div class="outline-text-4" id="text-6-5-2">
<ul class="org-ul">
<li>Input : A chain \(< A_1,A_2,...,A_n >\) of \(n\) matrices where for \(i=1,2,...,n\)
  matrix \(A_i\) has dimension \(p_{i-1} \times p_i\)</li>
<li>Output : A full parenthesization of the product \(A_1A_2...A_n\) in a way that
minimizes the number of scala multiplications.</li>
<li>Remarks :
<ul class="org-ul">
<li>We are not asked to calculate the product, only find the best parenthesization</li>
<li>The parenthesization can significantly affect the number of multiplications</li>
</ul></li>
<li>Example :
<ul class="org-ul">
<li>A product \(A_1A_2A_3\) with dimensions: \(50 \times 5\), \(5 \times 100\) and
\(100 \times 10\)</li>
<li>Calculating \((A_1A_2)A_3\) requires: \(50  5  100 + 50  100  10 = 75000\)
    scalar multiplications.</li>
<li>Calculating \(A_1(A_2A_3)\) requires: \(5  100  10 + 50  5  10 = 7500\)
    scalar multiplications.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline89" class="outline-4">
<h4 id="orgheadline89"><span class="section-number-4">6.5.3</span> Optimal substructure</h4>
<div class="outline-text-4" id="text-6-5-3">
<p>
<span class="underline">Theorem</span> :
</p>

<p>
if :
</p>
<ul class="org-ul">
<li>the outermost parenthesization in an optimal solution is :
\((A_1A_2...A_i)(A_{i+1}A_{i+2}...A_n)\)</li>
<li>\(P_L\) and \(P_R\) are optimal parenthesizations for \(A_1A_2...A_i\) and
\(A_{i+1}A_{i+2}...A_n\) respectively</li>
</ul>
<p>
Then, \(((P_L)(P_R))\) is an optimal parenthesizations for \(A_1A_2...A_n\)
</p>

<p>
<span class="underline">Proof</span> :
</p>
<ul class="org-ul">
<li>Let \(((O_L)(O_R))\) be an optimal parenthesization, where \(O_L\) and \(O_R\) are
parenthesization for \(A_1A_2...A_i\) and \(A_{i+1}A_{i+2}...A_n\) respectively</li>
<li>Let \(M(P)\) be the number of scalar multiplications required by a
parenthesization</li>
</ul>

\begin{align*}
M((O_L)(O_R)) &= p_0p_ip_n+M(O_L)+M(O_R)\\
&\ge p_0p_ip_n+M(P_L)+M(P_R) = M((P_L)(P_R))
\end{align*}

<ul class="org-ul">
<li>Since \(P_L\) and \(P_R\) are optimal: \(M(P_L) \le M(O_L)\) and \(M(P_R) \le M(O_R)\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline90" class="outline-4">
<h4 id="orgheadline90"><span class="section-number-4">6.5.4</span> Recursive formula</h4>
<div class="outline-text-4" id="text-6-5-4">
<ul class="org-ul">
<li>Let \(m[i,j]\) be the optimal number of scalar multiplications for calulating
\(A_iA_{i+1}....A_J\)</li>
<li>\(m[i,j]\) can be expressed recusively as follows :</li>
</ul>
<p>
\(m[i,j] = 0\) if i = j
</p>

<p>
\(m[i,j] = min_{i\le k < j}\lbrace m[i,k]+m[k+1,j]+p_{i-1}p_kp_j\rbrace\) if i &lt; j
</p>
<ul class="org-ul">
<li>Each \(m[i,j]\) depend only on subproblems with smaller \(j-i\)</li>
<li>A bottom-up algorithm should solve subproblems in increasing \(j-i\) order</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline91" class="outline-4">
<h4 id="orgheadline91"><span class="section-number-4">6.5.5</span> Bottom-up algorithm</h4>
<div class="outline-text-4" id="text-6-5-5">
<p>
<b>MATRIX-CHAIN-ORDER</b> \((p)\)
</p>
<div class="org-src-container">

<pre class="src src-java">n = p.length - <span style="color: #268bd2; font-weight: bold;">1</span>
let m<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span>..n,<span style="color: #268bd2; font-weight: bold;">1</span>..n<span style="color: #2aa198;">]</span> and s<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span>..n,<span style="color: #268bd2; font-weight: bold;">1</span>..n<span style="color: #2aa198;">]</span> be <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">tables</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n
  m<span style="color: #2aa198;">[</span>i,i<span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> l = <span style="color: #268bd2; font-weight: bold;">2</span> to n #l is the chain length
  <span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to n-l+<span style="color: #268bd2; font-weight: bold;">1</span>
    j = i + l -<span style="color: #268bd2; font-weight: bold;">1</span>
    m<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = infinity
    <span style="color: #859900; font-weight: bold;">for</span> k = <span style="color: #268bd2; font-weight: bold;">1</span> to j - <span style="color: #268bd2; font-weight: bold;">1</span>
      q = m<span style="color: #2aa198;">[</span>i,k<span style="color: #2aa198;">]</span> + m<span style="color: #2aa198;">[</span>k+<span style="color: #268bd2; font-weight: bold;">1</span>,j<span style="color: #2aa198;">]</span> + p<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>p<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span>p<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
      <span style="color: #859900; font-weight: bold;">if</span> q &lt; <span style="color: #b58900;">m</span><span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span>
        m<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = q
        s<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = k
<span style="color: #859900; font-weight: bold;">return</span> m and s
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline92" class="outline-4">
<h4 id="orgheadline92"><span class="section-number-4">6.5.6</span> Print optimal solution</h4>
<div class="outline-text-4" id="text-6-5-6">
<p>
<b>PRINT-OPTIMAL-PARENS</b> \((s,i,j)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> i == j
  print <span style="color: #2aa198;">"Ai"</span>
<span style="color: #859900; font-weight: bold;">else</span> print <span style="color: #2aa198;">"("</span>
  PRINT-OPTIMAL-PARENS<span style="color: #2aa198;">(</span>s, i, s<span style="color: #b58900;">[</span>i,j<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
  PRINT-OPTIMAL-PARENS<span style="color: #2aa198;">(</span>s,s<span style="color: #b58900;">[</span>i,j<span style="color: #b58900;">]</span>+<span style="color: #268bd2; font-weight: bold;">1</span>,j<span style="color: #2aa198;">)</span>
  print <span style="color: #2aa198;">")"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline93" class="outline-4">
<h4 id="orgheadline93"><span class="section-number-4">6.5.7</span> Summary</h4>
<div class="outline-text-4" id="text-6-5-7">
<p>
<span class="underline">Choice</span> where to make the outermost parenthesis
</p>

<p>
\((A_1...A_k)(A_{k+1}...A_n)\)
</p>

<p>
<span class="underline">Optimal substructure</span> : to obtain an optimal solution, we to parenthesize the
two remaining expressions in a optimal way.
</p>

<p>
Hence,  if we let \(m[i,j]\) be the optimal value for chain multiplication of
matrices \(A_i,...,A_j\), we can express \(m[i,j]\) recusively as follows
</p>

<p>
\(m[i,j] = 0\) if \(i=j\)
</p>

<p>
\(m[i,j] = min_{j\le k < j} \lbrace m[i,k] + m[k+1,j] + p_{i-1}p_k p_j\rbrace\)
otherwise if \(i < j\)
</p>

<p>
<span class="underline">Overlapping subproblems</span>: Solve reccurence using top-down with memoization or
bottom-up which yields an algorithm that runs in time \(\theta(n^3)\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline110" class="outline-2">
<h2 id="orgheadline110"><span class="section-number-2">7</span> Week 7</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline103" class="outline-3">
<h3 id="orgheadline103"><span class="section-number-3">7.1</span> Longest common subsequence</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<span class="underline">Input</span> : 2 sequences, \(X= < x_1,...x_m >\) and \(Y = < y_1,...,y_n >\)
</p>

<p>
<span class="underline">Output</span> : A subsequence common to both whose length is longest. (A
subsequence doesn't have to be consecutive, but it has to be in order)
</p>
</div>
<div id="outline-container-orgheadline96" class="outline-4">
<h4 id="orgheadline96"><span class="section-number-4">7.1.1</span> Brute force</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
For every subsequence of \(X\), check wether it's a subsequence of \(Y\)
</p>

<p>
Time : \(\Theta(n2^m)\)
</p>
<ul class="org-ul">
<li>\(2^m\) subsequences of \(X\) to check</li>
<li>Each subsequence takes \(\Theta(n)\) time to check: scan \(Y\) for first letter,
from there scan for second, and so on</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline102" class="outline-4">
<h4 id="orgheadline102"><span class="section-number-4">7.1.2</span> Dynamic programming</h4>
<div class="outline-text-4" id="text-7-1-2">
</div><div id="outline-container-orgheadline97" class="outline-5">
<h5 id="orgheadline97"><span class="section-number-5">7.1.2.1</span> Choice</h5>
<div class="outline-text-5" id="text-7-1-2-1">
<p>
Start at the end of both words and move to the left step-by-step
</p>

<p>
<b>Choice?</b>
</p>

<p>
If the same, pick letter to be in the subsequence
</p>

<p>
If not the same, optimal subsequence can be obtained by moving a step
to the left in one of the words.
</p>

<p>
Let \(X_i= < x_1 , x_2 , ... , x_i >\) and \(Y_i= < y_1,y_2,...,y_j >\)
</p>

<p>
<b>Choice</b>
</p>

<p>
if \(x_i = y_j\) then either
</p>
<ul class="org-ul">
<li>OPT "matches" \(x_i\) with \(y_j\) and remaining OPT is in (\(X_{i-1},Y_{j-1})\)</li>
<li>OPT is in \((X_{i-1},Y_j)\) or</li>
<li>OPT is in \(X_i,Y_{j-1}\)</li>
</ul>

<p>
if \(x_i \neq x_j\) then either
</p>
<ul class="org-ul">
<li>OPT is in \((X_{i-1},Y_j)\) or</li>
<li>OPT is in \(X_i,Y_{j-1}\)</li>
</ul>

<p>
We prove that we can assume that OPT matches \(x_i\) with \(y_j\) if they are
equal so we can simplify the first case
</p>
</div>
</div>

<div id="outline-container-orgheadline98" class="outline-5">
<h5 id="orgheadline98"><span class="section-number-5">7.1.2.2</span> Optimal substructure</h5>
<div class="outline-text-5" id="text-7-1-2-2">
<p>
Let \(X_i\) and \(Y_j\) denote the prefixes \(< x_1,x_2,...,x_i >\) and \(< y_1,y_2,...,y_j >\)
</p>

<p>
Theorem :
</p>

<p>
Let \(Z_k= < z_1 , z_2 , ... , z_k >\) be any LCS of \(X_i\) and \(Y_j\)
</p>

<ol class="org-ol">
<li>If \(x_i = y_j\) then \(z_k = x_i = y_j\) and \(Z_{k-1}\) is an LCS of \(X_{i-1}\) and \(Y_{j-1}\)</li>
<li>If \(x_i \neq y_j\) \(z_k \neq x_i\) &rArr; \(Z\) is an LCS of \(X_{i-1}\) and \(Y_j\)</li>
<li>If \(x_i \neq y_j\) \(z_k \neq y_j\) &rArr; \(Z\) is an LCS of \(X_i\) and \(Y_{j-1}\)</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline99" class="outline-5">
<h5 id="orgheadline99"><span class="section-number-5">7.1.2.3</span> Recursive formulation</h5>
<div class="outline-text-5" id="text-7-1-2-3">
<p>
Define \(c[i,j] =\) length of LCS of \(X_i\) and \(Y_j\). We want \(c[m,n]\)
</p>

\begin{align*}
  c[i,j]=\begin{cases}
    0 & \text{if $i=0$ or $j=0$}\\
    c[i-1,j-1] + 1 & \text{if $i,j>0$ and $x_i=y_j$}\\
    \text{max}(c[i-1,j],c[i,j-1]) & \text{if $i,j>0$ and $x_i \neq y_j$}
  \end{cases}
\end{align*}
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-5">
<h5 id="orgheadline100"><span class="section-number-5">7.1.2.4</span> Bottom-up pseudocode</h5>
<div class="outline-text-5" id="text-7-1-2-4">
<p>
<b>LCS-LENGTH</b> \((X,Y,m,n)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">let</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">1</span>..m,<span style="color: #268bd2; font-weight: bold;">1</span>..n<span style="color: #2aa198;">]</span> and c<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>..m,o..n<span style="color: #2aa198;">]</span> be <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">tables</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to m
  c<span style="color: #2aa198;">[</span>i,<span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">0</span> to n
  c<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">0</span>,j<span style="color: #2aa198;">]</span> = <span style="color: #268bd2; font-weight: bold;">0</span>
<span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2; font-weight: bold;">1</span> to m
  <span style="color: #859900; font-weight: bold;">for</span> j = <span style="color: #268bd2; font-weight: bold;">1</span> to n
    <span style="color: #859900; font-weight: bold;">if</span> x_i == y_j
      c<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span>=c<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">1</span>,j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>+<span style="color: #268bd2; font-weight: bold;">1</span>
      b<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"Top-left arrow"</span>
    <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> c<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">1</span>,j<span style="color: #2aa198;">]</span> &gt;= c<span style="color: #2aa198;">[</span>i,j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
      c<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = c<span style="color: #2aa198;">[</span>i-<span style="color: #268bd2; font-weight: bold;">1</span>,j<span style="color: #2aa198;">]</span>
      b<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"Top arrow"</span>
      <span style="color: #859900; font-weight: bold;">else</span>
        c<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = c<span style="color: #2aa198;">[</span>i,j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">]</span>
        b<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"right arrow"</span>   
<span style="color: #859900; font-weight: bold;">return</span> c and b
</pre>
</div>

<ul class="org-ul">
<li>Time dominated by instructions inside the two nested loops which execute
\(m\cdot n\) times</li>
<li>Total time is \(\Theta(m\cdot n)\)</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline101" class="outline-5">
<h5 id="orgheadline101"><span class="section-number-5">7.1.2.5</span> Printing solution pseudocode</h5>
<div class="outline-text-5" id="text-7-1-2-5">
<p>
<b>PRINT-LCS</b> \((b,X,i,j)\)
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">if</span> i == <span style="color: #268bd2; font-weight: bold;">0</span> or j == <span style="color: #268bd2; font-weight: bold;">0</span>
  <span style="color: #859900; font-weight: bold;">return</span>
<span style="color: #859900; font-weight: bold;">if</span> b<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> == <span style="color: #2aa198;">"top left arrow"</span>
  PRINT-LCS<span style="color: #2aa198;">(</span>b,X,i-<span style="color: #268bd2; font-weight: bold;">1</span>,j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">)</span>
  print x_i
<span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> b<span style="color: #2aa198;">[</span>i,j<span style="color: #2aa198;">]</span> == <span style="color: #2aa198;">"top arrow"</span>
  PRINT-LCS<span style="color: #2aa198;">(</span>b,X,i-<span style="color: #268bd2; font-weight: bold;">1</span>,j<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">else</span> PRINT-LCS<span style="color: #2aa198;">(</span>b,X,i,j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">)</span>
</pre>
</div>

<ul class="org-ul">
<li>Each recursive call decreases \(i + j\) by at least one.</li>
<li>Hence, if we let \(n = i + j\), the time needed is at most</li>
</ul>
<p>
\(T(n) \le T(n  1) + \Theta(1)\) which is \(O(n)\)
</p>
<ul class="org-ul">
<li>We can thus print the found string in time \(\Theta(|X | + |Y |)\)</li>
</ul>
<p>
(the lower bound following from that \(T(n) \ge T(n  2) + \Theta(1)\))
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline109" class="outline-3">
<h3 id="orgheadline109"><span class="section-number-3">7.2</span> Optimal binary search trees</h3>
<div class="outline-text-3" id="text-7-2">
</div><div id="outline-container-orgheadline104" class="outline-4">
<h4 id="orgheadline104"><span class="section-number-4">7.2.1</span> Idea</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>Give sequence \(K= < k_1,k_2,...,k_n >\) of \(n\) distinct keys, sorted
(\(k_1 < k_2 < ... < k_n\))</li>
<li>Want to build a binary search tree from the keys</li>
<li>For \(k_i\), have probability \(p_i\) that a search is for \(k_i\)</li>
<li>Want BST with minimum expected shared cost</li>
<li>Actual cost = # of items examined</li>
</ul>

<p>
For key \(k_i\), cost = \(\text{depth}_T(k_i) + 1\), where \(\text{depth}_T(k_i)\)
denotes the depth of \(k_i\) in BST T
</p>

\begin{align*}
\mathbb{E}[\text{search cost in }T] &= \sum\limits_{i=1}^n (\text{depth}_T(k_i) + 1 )p_i\\
&= 1+ \sum\limits_{i=1}^n (\text{depth}_T(k_i))p_i 
\end{align*}
</div>
</div>
<div id="outline-container-orgheadline105" class="outline-4">
<h4 id="orgheadline105"><span class="section-number-4">7.2.2</span> Observations</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>Optimal BST might not have smallest height</li>
<li>Optimal BST might not have highest-probability key at root</li>
</ul>

<p>
<b>Build by exhaustive checking ?</b>
</p>
<ul class="org-ul">
<li>Construct each \(n-\) node BST</li>
<li>For each put in keys</li>
<li>Then compute expected search cost</li>
<li>But there are exponentially many trees</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline106" class="outline-4">
<h4 id="orgheadline106"><span class="section-number-4">7.2.3</span> Optimal substructure</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
A binary search tree can be built by first picking the root and then building
the subtrees recursively
</p>

<p>
After picking root solution to subtrees must be optimal
</p>

<p>
add image slide
</p>
</div>
</div>

<div id="outline-container-orgheadline107" class="outline-4">
<h4 id="orgheadline107"><span class="section-number-4">7.2.4</span> Recursive formulation</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
Let \(e[i,j]=\) expected search cost of optimal BST of \(k_i,...,k_j\)
</p>

\begin{align*}
  e[i,j]=\begin{cases}
    0 & \text{if $i=j+1$}\\
    \text{min}_{i\le r\le j} \lbrace e[i,r-1]+e[r+1,j]+\sum\limits_{l=i}^j p_{\mathcal{l}} \rbrace & \text{if $i \le j$}
  \end{cases}
\end{align*}
</div>
</div>

<div id="outline-container-orgheadline108" class="outline-4">
<h4 id="orgheadline108"><span class="section-number-4">7.2.5</span> Bottom-up pseudocode</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2015-11-01 Sun 14:52</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
